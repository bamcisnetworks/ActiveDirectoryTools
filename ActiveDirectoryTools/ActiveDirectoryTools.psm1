#Try to import these, but silently continue on error since another module
#may use this as a dependency, but doesn't have these installed yet
if ((Get-Module -Name ActiveDirectory) -eq $null)
{
	Import-Module -Name ActiveDirectory -ErrorAction SilentlyContinue
}

if ((Get-Module -Name GroupPolicy) -eq $null)
{
	Import-Module -Name GroupPolicy -ErrorAction SilentlyContinue
}

Function Import-WmiFiltersFromJson {
	<#
		.SYNOPSIS
			Imports WMI Filter information from a JSON file.

		.DESCRIPTION
			The cmdlet uses a backup of WMI filters written to a json file to restore each WMI filter in the provided domain.

		.PARAMETER Path
			The location of the json file containing the WMI information. This file is created with the Export-GPOBackupsAndWmiFilters cmdlet. It can also be created manually.

		.PARAMETER Domain
			The domain to import the WMI filters. This defaults to the domain of the current user.

		.PARAMETER Force
			Overwrites any existing WMI filters.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.PARAMETER CimSession
			Specifies the CIM session to use for this cmdlet. Enter a variable that contains the CIM session or a command that creates or gets the CIM session, such as the New-CimSession or Get-CimSession cmdlets. For more information, see about_CimSessions.

        .EXAMPLE
			Import-WmiFiltersFromJson -Path "c:\GPOBackups\WmiFilters.json" -Domain "contoso.com"

			Imports the WMI filters stored at c:\GPOBackups\WmiFilters.json that were backed up to that path with Export-GPOBackupsAndWmiFilters to contoso.com. 

		.INPUTS
			System.String

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/30/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param (
		[Parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true)]
		[ValidateScript({ Test-Path -Path $_ })]
		[System.String]$Path,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[Switch]$Force,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[ValidateNotNull()]
        [Microsoft.Management.Infrastructure.CimSession]$CimSession = $null
	)

	Begin {
	}

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ($CimSession -eq $null)
        {
            $CimSession = New-CimSession
        }

		if ($Domain -eq [System.String]::Empty)
		{
			$Domain = $env:USERDOMAIN
		}

		$ADDomain = Get-ADDOmain -Identity $Domain @CredSplat

		$DomainDN = $ADDomain.DistinguishedName
		$DomainName = $ADDomain.DnsRoot

		$Server = $DomainName

		#If the local system account executing this cmdlet is a domain controller, set the server to this computer
		if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem) 
		{
			$Role = Get-CimInstance -Class Win32_OperatingSystem -Property ProductType -CimSession $CimSession | Select-Object -ExpandProperty ProductType
			
			if ($Role -eq 2) 
			{
				$Server = $env:COMPUTERNAME
			}
		}

		$WmiPath = "CN=SOM,CN=WMIPolicy,CN=System,$DomainDN"

		$WmiFilters = Get-Content -Path $Path -Raw @CredSplat | ConvertFrom-Json

		foreach ($Filter in $WmiFilters)
		{
			$Attr = @{
				"msWMI-Name" = $Filter."msWMI-Name";
				"msWMI-Parm1" = if ($Filter."msWMI-Parm1" -ne $null) { $Filter."msWMI-Param1"} else {$Filter."msWMI-Name"};
				"msWMI-Parm2" = $Filter."msWMI-Parm2";
				"msWMI-Author" = $Filter."msWMI-Author";
				"msWMI-ID"= $Filter."msWMI-ID";
				"instanceType" = 4;
				"showInAdvancedViewOnly" = "TRUE";
				"distinguishedname" = "CN=$($Filter."msWMI-ID"),$WmiPath";
				"msWMI-ChangeDate" = $Filter."msWMI-ChangeDate"; 
				"msWMI-CreationDate" = $Filter."msWMI-CreationDate"
			}

			$ExistingFilter = $null

			try 
			{
				$ExistingFilter = Get-ADObject -Identity $Attr.distinguishedname -Server $Server -ErrorAction Stop @CredSplat
			}
			catch [Exception] 
			{
				Write-Verbose -Message "[ERROR] $($_.Exception.Message)"
			}

			if ($ExistingFilter -ne $null)
			{
				if ($Force)
				{
					Write-Verbose -Message "Replacing $($Attr.'msWMI-Name') WMI Filter"
					Remove-ADObject -Identity $Attr.distinguishedname -Confirm:$false -Server $Server @CredSplat				
					New-ADObject -Name $Attr."msWMI-ID" -Type "msWMI-Som" -Path $WmiPath -OtherAttributes $Attr -Server $Server @CredSplat
				}
				else
				{
					Write-Warning -Message "The WMI Filter $($Attr.'msWMI-Name') with this ID already exists."
				}
			}
			else
			{
				Write-Verbose -Message "Importing $($Attr.'msWMI-Name') WMI Filter"
				New-ADObject -Name $Attr."msWMI-ID" -Type "msWMI-Som" -Path $WmiPath -OtherAttributes $Attr -Server $Server @CredSplat
			}
		}
	}

	End {
	}
}

Function Import-GPOPermissionsFromJson {
	<#
		.SYNOPSIS
			Imports Group Policy object permissions information from a JSON file and applies them to applicable GPOs.

		.DESCRIPTION
			The cmdlet uses a backup of GPO permissions written to a json file recreate permissions on exported GPOs.

		.PARAMETER Path
			The location of the json file containing the Group Policy permissions. This file is created with the Export-GPOBackupsAndWmiFilters cmdlet. It can also be created manually.

		.PARAMETER Domain
			The domain to import the Group Policy object permissions to. This defaults to the domain of the current user.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

			The Set-GPPermission cmdlet used in this function does not accept a Credential parameter, so the user privileges must have permissions to at least perform those functions. Other functions will be executed with the specified credentials.

        .EXAMPLE
			Import-GPOPermissionsFromJson -Path "c:\GPOBackups\GPPermissions.json" -Domain "contoso.com"

			Imports the Group Policy permissions stored at c:\GPOBackups\GPPermissions.json that were backed up to that path with Export-GPOBackupsAndWmiFilters to contoso.com. 

		.INPUTS
			System.String

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true)]
		[ValidateScript({ Test-Path -Path $_ })]
		[System.String]$Path,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {	
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ([System.String]::IsNullOrEmpty($Domain)) 
		{
			$Domain = (Get-ADDomain -Current LoggedOnUser @CredSplat).DnsRoot
		}

		[String[]]$Drives = Get-PSDrive | Select-Object -ExpandProperty Name

		$TempDrive = "tempdrive"

        if ($Drives.Contains($TempDrive))
        {
            Write-Verbose -Message "An existing PSDrive exists with name $TempDrive, temporarily removing"
			$OldDrive = Get-PSDrive -Name $TempDrive
			Remove-PSDrive -Name $TempDrive
		}

        $Drive = New-PSDrive -Name $TempDrive -Root "" -PSProvider ActiveDirectory -Server $Domain @CredSplat
		Push-Location -Path "$Drive`:\"

		$GPOs = Get-GPO -All -Domain $Domain -Server $Domain

		$Permissions = ConvertFrom-Json -InputObject (Get-Content -Path $Path -Raw @CredSplat)

		foreach ($Permission in ($Permissions | Where-Object {($GPOs | Select-Object -ExpandProperty DisplayName).Contains($_.Name) })) {
			Write-Host -Object "********  Processing $($Permission.Name) ********"
			Write-Host -Object ""

			$GPO = Get-GPO -Name $Permission.Name -Domain $Domain -Server $Domain

			switch ($Permission.Type) 
			{
				"ACL" {
					Write-Host -Object "Using ACL type permission."
					$Name = $Permission.Trustee.Name

					$ADObject = Get-ADObject -Filter {(name -eq $Name) -or (samAccountName -eq $Name)} -Properties * @CredSplat

					if ($ADObject -ne $null) {
						$GPOACL = Get-Acl -Path $GPO.Path

						foreach ($Entry in $Item.Permission) 
						{
							[System.DirectoryServices.ActiveDirectoryAccessRule]$NewAce = New-Object -TypeName System.DirectoryServices.ActiveDirectoryAccessRule( `
								$ADObject.ObjectSID, $Entry.ActiveDirectoryRights, $Entry.AccessControlType, $Entry.InheritanceType)
     
							$GPOACL.AddAccessRule($NewAce)
						}
                    
						# Commit the ACL
						Set-Acl -Path $GPO.Path -AclObject $GPOACL -Passthru
					}
					else {
						Write-Warning -Message "Could not find an AD Object matching $Name."
					}

					break
				}
				"GPPermission" {
					Write-Host -Object "Using GPPermission type permission."
					$SidType =[Microsoft.GroupPolicy.SecurityIdentifierType]($Permission.Trustee.SidType)
					$TrusteeName = $Permission.Trustee.Name

					try 
					{
						switch ($SidType) 
						{
							([Microsoft.GroupPolicy.SecurityIdentifierType]::Group) {
								if ((Get-ADGroup -Filter {name -eq $TrusteeName}) -ne $null) 
								{
									Set-GPPermission -Guid $GPO.Id -PermissionLevel $Permission.Permission -Replace -TargetType $Permission.Trustee.SidType -TargetName $Permission.Trustee.Name
								}
								else 
								{
									Write-Warning -Message "Could not find a group matching $($Permission.Trustee.Name)."
								}
								break
							}
							([Microsoft.GroupPolicy.SecurityIdentifierType]::WellKnownGroup) 
							{
								Set-GPPermission -Guid $GPO.Id -PermissionLevel $Permission.Permission -Replace -TargetType ([Microsoft.GroupPolicy.Commands.PermissionTrusteeType]::Group) -TargetName $Permission.Trustee.Name
								break
							}
							([Microsoft.GroupPolicy.SecurityIdentifierType]::User) 
							{
								if ((Get-ADUser -Filter {(name -eq $TrusteeName) -or (displayName -eq $TrusteeName) -or (samAccountName -eq $TrusteeName)} @CredSplat) -ne $null) 
								{
									Set-GPPermission -Guid $GPO.Id -PermissionLevel $Permission.Permission -Replace -TargetType $Permission.Trustee.SidType -TargetName $Permission.Trustee.Name
								}
								else {
									Write-Warning -Message "Could not find a user matching $($Permission.Trustee.Name)."
								}
								break
							}
							([Microsoft.GroupPolicy.SecurityIdentifierType]::Computer) 
							{
								if ((Get-ADComputer -Filter {(name -eq $TrusteeName) -or (displayName -eq $TrusteeName) -or (samAccountName -eq $TrusteeName) } @CredSplat) -ne $null) 
								{
									Set-GPPermission -Guid $GPO.Id -PermissionLevel $Permission.Permission -Replace -TargetType $Permission.Trustee.SidType -TargetName $Permission.Trustee.Name
								}
								else 
								{
									Write-Warning -Message "Could not find a computer matching $TrusteeName."
								}
								break
							}
							default 
							{
								Write-Warning -Message "The trustee type $SidType did not match an expected value of Group, WellKnownGroup, User, or Computer."
								break
							}
						}
					}
					catch [Exception] 
					{
						Write-Warning -Message "Set-GPPermission`n$($Permission.Name)`n$($Permission.Trustee.Name)`n$($Permission.Permission)`n$($_.Exception.Message)"
					}
                    
					break
				}
				default 
				{
					Write-Warning -Message "The ACL type $($Permission.Type) did not match GPPermission or ACL."
					break
				}
			}
		}

		Pop-Location

		Remove-PSDrive $Drive

        if ($OldDrive -ne $null)
        {
            Write-Verbose -Message "Recreating original PSDrive"
            New-PSDrive -Name $OldDrive.Name -PSProvider $OldDrive.Provider -Root $OldDrive.Root @CredSplat | Out-Null
            $OldDrive = $null
        }
	}

	End {
	}
}

Function Export-GPOBackupsAndWmiFilters {
	<#
		.SYNOPSIS
			Backups all GPOs in a given domain and writes all WMI Filter information to a JSON file. The permissions for each GPO are also written to a JSON file.

		.DESCRIPTION
			The cmdlet uses a native backup of every GPO in the domain. Then it queries all of the WMI filters and backs them up to a JSON files. The JSON file can be read later and used to restore all of the WMI filters.

			The permissions on each GPO are also backed up to a separate JSON file, which can be used later to set permissions on GPOs that have already been imported.

		.PARAMETER Path
			The directory location to store the backups. This directory will be created if it does not exist.

		.PARAMETER Domain
			The domain from which to backup GPOs. This defaults to the domain of the current user.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password. 
			
			Requires the ability to create the folder the backups will be stored in and read Active Directory objects and attributes.

        .EXAMPLE
			Export-GPOBackupsAndWmiFilter -Path "c:\GPOBackups" -Domain "contoso.com"

			Exports all of the GPO backups and WMI filter information for contoso.com to the specified path.

		.INPUTS
			System.String

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Path,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process
	{		
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ($Domain -eq [System.String]::Empty)
		{
			$Domain = $env:USERDOMAIN
		}

		$Domain = (Get-ADDomain -Identity $Domain @CredSplat).DnsRoot

		$Server = $Domain

		if (Test-IsEnterpriseOrDomainAdmin -Domain $Domain @CredSplat)
		{
			$GPOs = Get-GPO -All -Domain $Domain

			foreach($GPO in $GPOs)
			{
				$BackupDirectory = ($Path + "\" + $GPO.DisplayName.Replace(",","").Replace(":","").Replace("*",""))
				if (!(Test-Path -Path $BackupDirectory))
				{
					New-Item -Path $BackupDirectory -ItemType Directory -Force @CredSplat | Out-Null
				}
				
				Backup-GPO -Guid $GPO.Id -Path $BackupDirectory -Comment "Backed up on $(Get-Date)" -Server $Server -Domain $Domain 
			}

			$PermissionsBackupFile = New-Item -Path "$Path\GPPermissions.json" -ItemType File -Force @CredSplat
			Export-GPOPermissions -All -Domain $Domain -Destination $PermissionsBackupFile.FullName @CredSplat
			
			$WmiFilters = Get-ADObject -Filter {objectClass -eq "msWMI-Som"} -Properties "msWMI-Author","msWMI-ChangeDate","msWMI-CreationDate","msWMI-ID","msWMI-Name","msWMI-Parm1","msWMI-Parm2" -Server $Server @CredSplat

			if ($WmiFilters -ne $null -and $WmiFilters.Count -gt 0) 
			{
				Write-Host -Object "Backing up WMI Filters."
				$WmiBackupFile = New-Item -Path "$Path\WmiFilters.json" -ItemType File -Force @CredSplat

				$WmiFilters = $WmiFilters | Select-Object -Property "msWMI-Author","msWMI-ChangeDate","msWMI-CreationDate","msWMI-ID","msWMI-Name","msWMI-Parm1","msWMI-Parm2"

				$Json = ConvertTo-Json -InputObject $WmiFilters 
				$Json = $Json.Replace("null", "`"`"")
				Set-Content -Value $Json -Path $WmiBackupFile -Force @CredSplat

				Write-Host "Completed WMI Filter backup."
			} 
			else 
			{
				Write-Host "No WMI filters in the domain."
			}
		}
		else
		{
			throw [System.UnauthorizedAccessException]("You must be at least a Domain Admin to utilize this cmdlet.")
		}
	}

	End {
	}
}

Function Export-GPOPermissions {
	<#
		.SYNOPSIS
			Exports all of the permission information of GPOs to a JSON file.

		.DESCRIPTION
			The cmdlet uses the get Get-GPPermission command to get initial information. Any GPOs with custom permissions have their permissions enumerated via ACL. All of the permissions are written to a JSON file that can be used with Import-GPPermissionsFromJson.

		.PARAMETER DisplayNames
			The names of the GPOs whose permissions should be backed up.

		.PARAMETER All
			Specifies that all GPOs should have their permissions backed up.

		.PARAMETER Domain
			The domain from which to backup GPO permissions in. This defaults to the domain of the current user.

		.PARAMETER Destination
			The file that should be created with the permission information. If the file exists, the content will be overwritten.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Export-GPOPermissions -All -Destination c:\GPPermissions.json

			Exports all of the GPO permissions to c:\GPPermissions.json

		.EXAMPLE
			Export-GPOPermissions -DisplayNames @("Default Domain Policy","Default Domain Controllers Policy") -Destination c:\GPPermissions.json

			Exports the permissions for the Default Domain Policy and Default Domain Controllers Policy to c:\GPPermissions.json

		.INPUTS
			None

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>
	[CmdletBinding(DefaultParameterSetName = "Names")]
	[OutputType()]
	Param(
		[Parameter(Position = 0, ParameterSetName = "Names", Mandatory = $true)]
		[ValidateScript({$_.Count -gt 0})]
		[System.String[]]$DisplayNames,

		[Parameter(Position = 0, ParameterSetName="All", Mandatory = $true)]
		[Switch]$All,

		[Parameter(Position = 1, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Destination,

		[Parameter(Position = 2)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,
		
		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[Switch]$PassThru			
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ([System.String]::IsNullOrEmpty($Domain)) 
		{
			$Domain = $env:USERDOMAIN
		}

		$Domain = (Get-ADDomain -Identity $Domain @CredSplat).DnsRoot

		$GPOs = @()

		if ($PSCmdlet.ParameterSetName -eq "All") 
		{
			$GPOs += Get-GPO -All
		}
		else 
		{
			foreach ($Name in $DisplayNames) 
			{
				try 
				{
					$GPOs += Get-GPO -Name $Name -ErrorAction Stop
				}
				catch [Exception] 
				{
					Write-Verbose -Message $_.Exception.Message
				}
			}
		}

		[PSCustomObject[]]$ACLs = @()

		[System.String[]]$Drives = Get-PSDrive | Select-Object -ExpandProperty Name

		$TempDrive = "tempdrive"

        if ($Drives.Contains($TempDrive))
        {
            Write-Verbose -Message "An existing PSDrive exists with name $TempDrive, temporarily removing"
			$OldDrive = Get-PSDrive -Name $TempDrive
			Remove-PSDrive -Name $TempDrive
		}

        $Drive = New-PSDrive -Name $TempDrive -Root "" -PSProvider ActiveDirectory -Server $Domain @CredSplat
		Push-Location -Path "$Drive`:\"

		foreach ($GPO in $GPOs) 
		{
			Write-Host -Object "Processing $($GPO.DisplayName) permissions."
			$Permissions = Get-GPPermission -Name $GPO.DisplayName -All 

			foreach ($Permission in $Permissions) 
			{

				$Trustee = [PSCustomObject]@{"Domain" = $Permission.Trustee.Domain; "DSPath" = $Permission.Trustee.DSPath; "Name" = $Permission.Trustee.Name; "Sid" = $Permission.Trustee.Sid; "SidType" = $Permission.Trustee.SidType}

				if ($Permission.Permission -eq [Microsoft.GroupPolicy.GPPermissionType]::GpoCustom) 
				{
					[System.DirectoryServices.ActiveDirectoryAccessRule[]]$ACL = Get-Acl -Path "$($GPO.Path)" | Select-Object -ExpandProperty Access | Where-Object {$_.IdentityReference.ToString().Split("\\")[-1] -eq $Permission.Trustee.Name }

					$Rights = @()

					foreach ($ACE in $ACL) 
					{
						$Rights += [PSCustomObject]@{"ActiveDirectoryRights" = $ACE.ActiveDirectoryRights; "InheritanceType" = $ACE.InheritanceType; "AccessControlType" = $ACE.AccessControlType; "ObjectType" = $ACE.ObjectType; "InheritanceFlags" = $ACE.InheritanceFlags}
					}

					[PSCustomObject]$Entry = @{"Type" = "ACL";"Name" = $GPO.DisplayName; "Trustee" = $Trustee; "GPODistinguishedName" = $GPO.Path; "Permission" = $Rights; "Denied" = if ($ACE.AccessControlType -eq [System.Security.AccessControl.AccessControlType]::Deny) {$true} else {$false}}
				}
				else 
				{
					[PSCustomObject]$Entry = @{"Type" = "GPPermission"; "Name" = $GPO.DisplayName; "Trustee" = $Trustee; "GPODistinguishedName" = $GPO.Path; "Permission" = $Permission.Permission; "Denied" = $Permission.Denied}
				}
				
				$ACLs += $Entry            
			}
		}

		Pop-Location

		Remove-PSDrive -Name $Drive

        if ($OldDrive -ne $null)
        {
            Write-Host -Object "Recreating original PSDrive" -ForegroundColor Yellow
            New-PSDrive -Name $OldDrive.Name -PSProvider $OldDrive.Provider -Root $OldDrive.Root @CredSplat | Out-Null
            $OldDrive = $null
        }

		if (![System.String]::IsNullOrEmpty($Destination)) 
		{
			Set-Content -Path $Destination -Value (ConvertTo-Json -InputObject $ACLs -Depth 5) -Force -Confirm:$false @CredSplat
		}

		if ($PassThru)
		{
			Write-Output -InputObject $ACLs
		}
	}

	End {
	}
}

Function Import-FullGPOBackups {
	<#
		.SYNOPSIS
			Restores all most recent GPO backups stored under a given path and reassociates WMI filters to the GPO.

		.DESCRIPTION
			The cmdlet recursively searches the provided path for GPO backups. Once a backup is found, it is imported into the provided domain. After the import, the GPO Report XML
			is utilized to identify any WMI filters that were used, and reassociates those WMI filters to the GPO if they exist in the domain. This command is useful for restoring GPOs that
			were backed up natively and restoring them to a new domain after the WMI filters have been imported. 

		.PARAMETER Path
			The base path to start searching from.

		.PARAMETER Domain
			The domain to import the GPOs into. This defaults to the domain of the current user.

		.PARAMETER MigrationTablePath
			Optionally specify a migration table to be used to conduct the GPO import.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.
	
		.PARAMETER CimSession
			Specifies the CIM session to use for this cmdlet. Enter a variable that contains the CIM session or a command that creates or gets the CIM session, such as the New-CimSession or Get-CimSession cmdlets. For more information, see about_CimSessions.

        .EXAMPLE
			Import-FullGPOBackups -Path "c:\GPOBackups" -Domain "contoso.com"

			Import all of the backups contained in the folder structure to contoso.com and associate any WMI filters.

		.INPUTS
			None

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/8/2017

	#>

	[CmdletBinding()]
	[OutputType()]
	Param
    (
        [Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
        [System.String]$Path,

        [Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
        [System.String]$Domain = [System.String]::Empty,

		[Parameter(Position = 2)]
		[ValidateScript({
			if (![System.String]::IsNullOrEmpty($_)) 
			{
				Test-Path -Path $_
			}
			else
			{
				return $true
			}
		})]
		[System.String]$MigrationTablePath = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[ValidateNotNull()]
        [Microsoft.Management.Infrastructure.CimSession]$CimSession = $null
    )

    Begin {
    }

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ($CimSession -eq $null)
        {
            $CimSession = New-CimSession
        }

		if ($Domain -eq [System.String]::Empty)
		{
			$Domain = $env:USERDOMAIN
		}

		$DomainObject = Get-ADDomain -Identity $Domain @CredSplat

		$ADDomain = $DomainObject.DnsRoot
		$Server = $ADDomain
		$DomainDN = $DomainObject.DistinguishedName

		Write-Host -Object "Importing GPOs to $DomainDN."

		$DomainController = [System.String]::Empty

		if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem) 
		{
			$Role = Get-CimInstance -Class Win32_OperatingSystem -Property ProductType @CredSplat | Select-Object -ExpandProperty ProductType
			if ($Role -eq 2) 
			{
				$Server = $env:COMPUTERNAME
			}
		}

		$WmiFilters = Get-ADObject -Filter 'objectClass -eq "msWMI-SOM"' -SearchBase $DomainDN -Properties "msWMI-Author","msWMI-ChangeDate","msWMI-CreationDate","msWMI-ID","msWMI-Name","msWMI-Parm1","msWMI-Parm2" -Server $Server @CredSplat

		if ($WmiFilters -eq $null) 
		{
			$WmiFilters = @()
		}
	
		$Directories = Get-ChildItem -Path $Path -Recurse -Directory | Select-Object -ExpandProperty FullName

		foreach ($Directory in $Directories)
		{
			[Microsoft.GroupPolicy.BackupDirectory]$BackupDirectory = New-Object Microsoft.GroupPolicy.BackupDirectory($Directory, [Microsoft.GroupPolicy.BackupType]::Gpo)
            [Microsoft.GroupPolicy.GPSearchCriteria]$SearchCriteria = New-Object Microsoft.GroupPolicy.GPSearchCriteria
            $SearchCriteria.Add([Microsoft.GroupPolicy.SearchProperty]::MostRecentBackup, [Microsoft.GroupPolicy.SearchOperator]::Equals, $true)
            [Microsoft.GroupPolicy.GpoBackupCollection]$Backups = $BackupDirectory.SearchGpoBackups($SearchCriteria)

			if ($Backups -ne $null -and $Backups.Count -gt 0)
			{
				foreach($Backup in $Backups)
				{
					Write-Host "Importing $($Backup.BackupDirectory)"
					try
					{
						$MigSplat = @{}

						if (![System.String]::IsNullOrEmpty($MigrationTablePath)) 
						{
							$MigSplat["MigrationTable"] = $MigrationTablePath
						}
						
						$Gpo = Import-GPO -Path $Backup.BackupDirectory -BackupGpoName $Backup.DisplayName -CreateIfNeeded -Server $Server -Domain $ADDomain -TargetName $Backup.DisplayName -ErrorAction Stop @MigSplat
						Write-Host -Object "Successfully imported $($Gpo.DisplayName) to $($Gpo.DomainName)."
					}
					catch [Exception] 
					{
						Write-Warning -Message $_.Exception.Message
						Write-Warning -Message ($_.CategoryInfo.Category.ToString())
						Write-Warning -Message ($_.InvocationInfo | Format-List | Out-String)
						Write-Warning -Message ($_.ScriptStackTrace | Format-List | Out-String)		
						break
					}

					$Counter = 0

					while ($true) 
					{
						try 
						{
							#Make sure the GPO gets created
							$Temp = Get-ADObject -Identity "CN={$($Gpo.Id)},CN=Policies,CN=System,$DomainDN" -ErrorAction Stop @CredSplat
							break
						}
						catch [Exception] 
						{
							Write-Host -Object "Waiting for GPO $($Gpo.DisplayName) : $($Gpo.Id) to finish creation..."
							Start-Sleep -Seconds 1
							$Counter++

							if ($Counter -gt 60) 
							{
								Write-Warning -Message "Timeout waiting for the GPO to finish creation."
								$Gpo = $null
								break
							}
						}
					}

					if ($WmiFilters.Count -gt 0) 
					{
						[Xml]$GpoReport = $Backup.GenerateReport([Microsoft.GroupPolicy.ReportType]::Xml)
						$Namespace = New-Object System.Xml.XmlNamespaceManager($GpoReport.NameTable)
						$Namespace.AddNamespace("ns", $GpoReport.DocumentElement.NamespaceURI)
						[System.Boolean]$FilterDataAvailable = ($GpoReport.SelectSingleNode("//ns:FilterDataAvailable", $Namespace)).InnerText

						if ($Gpo -ne $null -and $FilterDataAvailable)
						{
							$WmiFilterName = ($GpoReport.SelectSingleNode("//ns:FilterName", $Namespace)).InnerText

							if (![System.String]::IsNullOrEmpty($WmiFilterName) -and $WmiFilters."msWMI-Name".Contains($WmiFilterName))
							{
								$WmiObject = $WmiFilters | Where-Object {$_."msWMI-Name" -eq $WmiFilterName} | Select-Object -First 1
								if ($WmiObject -ne $null) 
								{
									$WmiFilterId = $WmiObject."msWMI-ID"
									Write-Host -Object "Using WMI Filter ID: $WmiFilterId for: `nCN={$($Gpo.Id)},CN=Policies,CN=System,$DomainDN"
									
									try 
									{
										Set-ADObject -Identity "CN={$($Gpo.Id)},CN=Policies,CN=System,$DomainDN" -Replace @{gPCWQLFilter = "[$ADDomain;$WmiFilterId;0]"} -Server $Server @CredSplat
										Write-Host -Object "Added existing WMI Filter $WmiFilterName to the GPO."
									}
									catch [Exception] {
										Write-Warning -Message $_.Exception.Message
										Write-Warning -Message ($_.CategoryInfo.Category.ToString())
										Write-Warning -Message ($_.InvocationInfo | Format-List | Out-String)
										Write-Warning -Message ($_.ScriptStackTrace | Format-List | Out-String)							
									}
								}
								else 
								{
									Write-Warning -Message "Could not find the wmi filter even though the filter list contained a match."
								}
							}
						}
					}
					else
					{
						Write-Verbose -Message "No WMI filters discovered in $DomainDN."
					}
				}
			}
			else
			{
				Write-Verbose -Message "No backups discovered at $Directory."
			}
		}
	}

	End {
	}
}

Function Get-WmiFilter {
	<#
		.SYNOPSIS
			Gets WMI Filters in the domain.

		.DESCRIPTION
			The Get-WmiFilter cmdlet returns a specific WMI Filter object based on a name or GUID or returns all WMI Filters. Optionally, link information for where each WMI filter is applied can be returned.		

		.PARAMETER GUID
			The GUID of the WMI Filter to get.

		.PARAMETER Domain
			The domain to perform the search on. This defaults to the domain of the current user.

		.PARAMETER All
			Returns all WMI filters in the domain.

		.PARAMETER Name
			The "msWMI-Name" attribute of the WMI Filter to match.

		.PARAMETER IncludeLinkInformation
			If specified, information about where each WMI filter is applied is returned as well.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Get-WmiFilter -All -Domain contoso.com

			Gets all of the WMI Filters in contoso.com

		.EXAMPLE
			Get-WmiFilter -All -IncludeLinkInformation
			
			Gets all of the WMI filters and their link information for the domain of the current user.

		.INPUTS
			System.Guid
			
			System.String

		.OUTPUTS
			System.Management.Automation.PSObject[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>

	[CmdletBinding(DefaultParameterSetName = "Name")]
	[OutputType([System.Management.Automation.PSObject[]])]
	Param(
		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true, ParameterSetName = "Guid")]
		[ValidateNotNull()]
		[System.Guid]$Guid,

		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true, ParameterSetName = "Name")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Name,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter(Mandatory = $true, ParameterSetName = "All")]
		[Switch]$All,

		[Parameter()]
		[Switch]$IncludeLinkInformation,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ([System.String]::IsNullOrEmpty($Domain)) 
		{
			$Domain = $env:USERDOMAIN
		}

		$Domain = (Get-ADDomain -Identity $Domain @CredSplat).DnsRoot

		$WmiFilters = @()

		switch ($PSCmdlet.ParameterSetName) 
		{
			"Guid" {
				[System.String]$Guid = "{" + $Guid.ToString() + "}"
				$Filter = {(objectClass -eq "msWMI-SOM") -and (msWMI-ID -eq $Guid)} 
				break
			}
			"Name" {
				$Filter = {(objectClass -eq "msWMI-SOM") -and (msWMI-Name -eq $Name)} 
				break
			}
			"All" {
				$Filter = {objectClass -eq "msWMI-SOM"} 
				break
			}
			default {
				throw "Could not determine parameter set name."
			}
		}

        [PSObject[]]$WmiFilters = Get-ADObject -Filter $Filter -Properties "msWMI-Author","msWMI-ChangeDate","msWMI-CreationDate","msWMI-ID","msWMI-Name","msWMI-Parm1","msWMI-Parm2","DistinguishedName" -Server $Domain @CredSplat

		if ($WmiFilters -ne $null -and $WmiFilters.Length -gt 0)
		{
			if ($IncludeLinkInformation) 
			{
				$GPOs = Get-ADObject -Filter {objectClass -eq "groupPolicyContainer"} -Properties "gPCWQLFilter","displayName","name" @CredSplat | 
					Where-Object {![System.String]::IsNullOrEmpty($_.gPCWQLFilter)} | 
					Select-Object -Property "gPCWQLFilter","displayName","name" 

				foreach ($Filter in $WmiFilters) 
				{			
					Add-Member -InputObject $Filter -MemberType NoteProperty -Name "LinkInformation" -Value @() -TypeName [System.Management.Automation.PSObject[]] -Force	
						
					$Filter.LinkInformation += ($GPOs | Where-Object {$_.gPCWQLFilter.Split(";")[1] -eq $Filter.'msWMI-ID'} | Select-Object "DisplayName","name")
				}
			}

			Write-Output -InputObject $WmiFilters
		}
	}

	End {		
	}
}

Function New-StandardGPOWmiFilters {
	<#
		.SYNOPSIS
			Creates a standard set of WMI filters.

		.DESCRIPTION
			The cmdlet creates a set of WMI filters for each domain in the forest, or a particular domain. Some of the software filters use custom WMI classes Win32_Software and Win32_Software64 that can be installed through the Set-Win32Software script on PowerShellGallery.

		.PARAMETER Domain
			The domain to create the WMI filters in. This defaults to the domain of the current user.

		.PARAMETER WithReplace
			If a WMI filters exists with the same name as ones in the standard set, the WMI query expression is updated.

		.PARAMETER AddToForest
			Adds the WMI filters to each domain in the forest of the current user.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

			If the AddToForest parameter is specified, the credentials must have Enterprise Admin rights, otherwise they need Domain Admin rights for the specified domain.
			
        .EXAMPLE
			New-StandardGPOWmiFilters -AddToForest

			Creates standard WMI Filters in every domain in the current forest. The user must be an enterprise admin for this command to succeed.

		.EXAMPLE 
			New-StandardGPOWmiFilters -Domain contoso.com -WithReplace

			Creates standard WMI Filters in the contoso.com domain and replaces the query value for any existing filters that have a matching name as a new one being created through the cmdlet.

		.EXAMPLE
			New-StandardGPOWmiFilters 

			Creates standard WMI Filters in the current domain of the user. The user must be a domain admin for this command to succeed.

		.INPUTS
			System.String

		.OUTPUTS
			System.Collections.Hashtable[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding(DefaultParameterSetName="SpecifyDomain")]
	[OutputType([System.Collections.Hashtable[]])]
	Param(
		[Parameter(Mandatory = $true, ParameterSetName = "Forest")]
		[Switch]$AddToForest,

		[Parameter(Position = 0, ParameterSetName = "SpecifyDomain", ValueFromPipeLine = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[Switch]$WithReplace,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[Switch]$PassThru
	)

	Begin{		
	}

	Process
	{
		$Domains = @()

		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		switch ($PSCmdlet.ParameterSetName) 
		{
			"Forest" {
				if (!(Test-IsEnterpriseAdmin @CredSplat)) 
				{
					throw "The user must be an enterprise admin to create filters in every domain."
				}
				else 
				{
					$Domains += (Get-ADForest -Current LoggedOnUser @CredSplat).Domains
				}
				break
			}
			"SpecifyDomain" {			
				if ([System.String]::IsNullOrEmpty($Domain)) 
				{
					$Domain = Get-ADDomain -Current LoggedOnUser @CredSplat | Select-Object -ExpandProperty DnsRoot
				}

				if (!(Test-IsDomainAdmin -Domain $Domain @CredSplat)) 
				{
					throw "The user must be a domain admin to create filters in the specified domain."
				}
				else 
				{
					$Domains += $Domain
				}

				break
			}
			default {
				throw "Could not determine parameter set."
			}
		}
		$Output = @()

#region Filters
		$Filters = @()

#region AD and NON AD Management Workstations

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=1
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType=1
"@
		$ADManagementWorkstation=@{"Expression"=@($Expression,$Expression2);"Description"="Active Directory Management Workstation (Item Level Targetting)";"Name"="Active Directory Management Workstation (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $ADManagementWorkstation

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=0
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType=1
"@
		$NonADManagementWorkstation=@{"Expression"=@($Expression,$Expression2);"Description"="Non Active Directory Management Workstation (Item Level Targetting)";"Name"="Non Active Directory Management Workstation (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $NonADManagementWorkstation

		$ADMgmtWorkstations = @(
			@{"Version" = "6.0."; "Name" = "Windows 7"},
			@{"Version" = "6.1."; "Name" = "Windows Vista"},
			@{"Version" = "6.2."; "Name" = "Windows 8"},
			@{"Version" = "6.3."; "Name" = "Windows 8.1"},
			@{"Version" = "10.0"; "Name" = "Windows 10"}
		)

		foreach ($Item in $ADMgmtWorkstations) {

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=1
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND ProductType=1
"@
		$ADMgmt=@{"Expression"=@($Expression,$Expression2);"Description"="$($Item.Name) - Active Directory Management (Item Level Targetting)";"Name"="$($Item.Name) - Active Directory Management (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $ADMgmt

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=0
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND ProductType=1
"@
		$NonADMgmt=@{"Expression"=@($Expression,$Expression2);"Description"="$($Item.Name) - Non Active Directory Management (Item Level Targetting)";"Name"="$($Item.Name) - Non Active Directory Management (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $NonADMgmt

		}

#endregion

#region AD and NON AD Management Servers

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=1
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE (ProductType=2 OR ProductType=3)
"@
		$ADManagementServer=@{"Expression"=@($Expression,$Expression2);"Description"="Active Directory Management Server (Item Level Targetting)";"Name"="Active Directory Management Server (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $ADManagementServer

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=0
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE (ProductType=2 OR ProductType=3)
"@
		$NonADManagementServer=@{"Expression"=@($Expression,$Expression2);"Description"="Non Active Directory Management Server (Item Level Targetting)";"Name"="Non Active Directory Management Server (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $NonADManagementServer

		$ADMgmtServers = @(
			@{"Version" = "6.0."; "Name" = "Windows Server 2008"},
			@{"Version" = "6.1."; "Name" = "Windows Server 2008 R2"},
			@{"Version" = "6.2."; "Name" = "Windows Server 2012"},
			@{"Version" = "6.3."; "Name" = "Windows Server 2012 R2"},
			@{"Version" = "10.0"; "Name" = "Windows Server 2016"}
		)

		foreach ($Item in $ADMgmtServers) {
		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=1
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND ProductType=3
"@
		$ADMgmt=@{"Expression"=@($Expression,$Expression2);"Description"="$($Item.Name) - Active Directory Management (Item Level Targetting)";"Name"="$($Item.Name) - Active Directory Management (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $ADMgmt

		$Expression = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue=0
"@
		$Expression2 = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND ProductType=3
"@
		$NonADMgmt=@{"Expression"=@($Expression,$Expression2);"Description"="$($Item.Name) - Non Active Directory Management (Item Level Targetting)";"Name"="$($Item.Name) - Non Active Directory Management (Item Level Targetting)";"Namespace"="ROOT\CIMV2";}
		$Filters += $NonADMgmt

		}

#endregion

#region Web Browsers

		$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files\\Internet Explorer\\" AND filename="iexplore" AND extension="exe" AND version>="10" AND version<"11"
"@
		$IE10 = @{"Expression"=@($Expression);"Description"="Internet Explorer 10";"Name"="Internet Explorer 10";"Namespace"="ROOT\CIMV2";}
		$Filters += $IE10

		$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files\\Internet Explorer\\" AND filename="iexplore" AND extension="exe" AND version>="11" AND version<"12"
"@
		$IE11 = @{"Expression"=@($Expression);"Description"="Internet Explorer 11";"Name"="Internet Explorer 11";"Namespace"="ROOT\CIMV2";}
		$Filters += $IE11

		$Expression = @"
SELECT * FROM win32_software WHERE DisplayName = "Google Chrome"
"@
		$GoogleChrome = @{"Expression"=@($Expression);"Description"="Google Chrome";"Name"="Google Chrome";"Namespace"="ROOT\CIMV2";}
		$Filters += $GoogleChrome

		$Expression = @"
SELECT * from win32_software where DisplayName like "%Firefox%"
"@
		$MozillaFirefox = @{"Expression"=@($Expression);"Description"="Mozilla Firefox";"Name"="Mozilla Firefox";"Namespace"="ROOT\CIMV2";}
		$Filters += $MozillaFirefox

#endregion

#region Operating Systems
	
		$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType = "2" OR ProductType = "3"
"@
		$WindowsServer = @{"Expression"=@($Expression);"Description"="Windows Server";"Name"="Windows Server";"Namespace"="ROOT\CIMV2";}
		$Filters += $WindowsServer

		$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType = "3"
"@
		$MemberServer = @{"Expression"=@($Expression);"Description"="Member Server";"Name"="Member Server";"Namespace"="ROOT\CIMV2";}
		$Filters += $MemberServer
		
		$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType = "2"
"@
		$DomainController = @{"Expression"=@($Expression);"Description"="Domain Controller";"Name"="Domain Controller";"Namespace"="ROOT\CIMV2";}
		$Filters += $DomainController

		$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE ProductType = "1"
"@
		$WindowsClient = @{"Expression"=@($Expression);"Description"="Windows Client";"Name"="Windows Client";"Namespace"="ROOT\CIMV2";}
		$Filters += $WindowsClient

		$Workstations = @(
			@{"Version" = "6.0."; "Name" = "Windows 7"},
			@{"Version" = "6.1."; "Name" = "Windows Vista"},
			@{"Version" = "6.2."; "Name" = "Windows 8"},
			@{"Version" = "6.3."; "Name" = "Windows 8.1"},
			@{"Version" = "10.0"; "Name" = "Windows 10"}
		)

		foreach ($Item in $Workstations) {
			$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND ProductType = "1"
"@
			$Workstation = @{"Expression"=@($Expression);"Description"="$($Item.Name)";"Name"="$($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Workstation
		}

		$Servers = @(
			@{"Version" = "6.0."; "Name" = "Windows Server 2008"; "ProductType" = "(ProductType = `"3`" OR ProductType = `"2`")" },
			@{"Version" = "6.0."; "Name" = "Windows Server 2008 Member Server"; "ProductType" = "ProductType = `"3`""},
			@{"Version" = "6.0."; "Name" = "Windows Server 2008 Domain Controller"; "ProductType" = "ProductType = `"2`""},
			@{"Version" = "6.1."; "Name" = "Windows Server 2008 R2"; "ProductType" = "(ProductType = `"3`" OR ProductType = `"2`")" },
			@{"Version" = "6.1."; "Name" = "Windows Server 2008 R2 Member Server"; "ProductType" = "ProductType = `"3`""},
			@{"Version" = "6.1."; "Name" = "Windows Server 2008 R2 Domain Controller"; "ProductType" = "ProductType = `"2`""},
			@{"Version" = "6.2."; "Name" = "Windows Server 2012"; "ProductType" = "(ProductType = `"3`" OR ProductType = `"2`")" },
			@{"Version" = "6.2."; "Name" = "Windows Server 2012 Member Server"; "ProductType" = "ProductType = `"3`""},
			@{"Version" = "6.2."; "Name" = "Windows Server 2012 Domain Controller"; "ProductType" = "ProductType = `"2`""},
			@{"Version" = "6.3."; "Name" = "Windows Server 2012 R2"; "ProductType" = "(ProductType = `"3`" OR ProductType = `"2`")" },
			@{"Version" = "6.3."; "Name" = "Windows Server 2012 R2 Member Server"; "ProductType" = "ProductType = `"3`""},
			@{"Version" = "6.3."; "Name" = "Windows Server 2012 R2 Domain Controller"; "ProductType" = "ProductType = `"2`""},
			@{"Version" = "10.0"; "Name" = "Windows Server 2016"; "ProductType" = "(ProductType = `"3`" OR ProductType = `"2`")" },
			@{"Version" = "10.0"; "Name" = "Windows Server 2016 Member Server"; "ProductType" = "ProductType = `"3`""},
			@{"Version" = "10.0"; "Name" = "Windows Server 2016 Domain Controller"; "ProductType" = "ProductType = `"2`""}
		)

		foreach ($Item in $Servers) {
			$Expression = @"
SELECT * FROM Win32_OperatingSystem WHERE Version LIKE "$($Item.Version)%" AND $($Item.ProductType)
"@
			$Server = @{"Expression"=@($Expression);"Description"="$($Item.Name)";"Name"="$($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Server
		}

		#endregion

#region Microsoft Office
		
		$Office = @(
			@{"Name" = "Access"; "File" = "MSACCESS"},
			@{"Name" = "Excel"; "File" = "EXCEL"},
			@{"Name" = "Groove"; "File" = "GROOVE"},
			@{"Name" = "Infopath"; "File" = "INFOPATH"},
			@{"Name" = "Lync"; "File" = "lync"},
			@{"Name" = "OneNote"; "File" = "ONENOTE"},
			@{"Name" = "Outlook"; "File" = "OUTLOOK"},
			@{"Name" = "Powerpoint"; "File" = "POWERPNT"},
			@{"Name" = "Project"; "File" = "WINPROJ"},
			@{"Name" = "Publisher"; "File" = "MSPUB"},
			@{"Name" = "Sharepoint Designer"; "File" = "SPDESIGN"},
			@{"Name" = "Visio"; "File" = "VISION"},
			@{"Name" = "Word"; "File" = "WINWORD"}
		)

		foreach ($Item in $Office) {
			$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files (x86)\\Microsoft Office\\Office15\\" AND filename="$($Item.File)" AND extension="exe" AND version>="15" AND version<"16"
"@
			$Office2013x86 = @{"Expression"=@($Expression);"Description"="Microsoft Office 2013 x86 - $($Item.Name)";"Name"="Microsoft Office 2013 x86 - $($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Office2013x86

			$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files\\Microsoft Office\\Office15\\" AND filename="$($Item.File)" AND extension="exe" AND version>="15" AND version<"16"
"@
			$Office2013x64 = @{"Expression"=@($Expression);"Description"="Microsoft Office 2013 x64 - $($Item.Name)";"Name"="Microsoft Office 2013 x64 - $($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Office2013x64

			$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files (x86)\\Microsoft Office\\Office16\\" AND filename="$($Item.File)" AND extension="exe" AND version>="16" AND version<"17"
"@
			$Office2016x86 = @{"Expression"=@($Expression);"Description"="Microsoft Office 2016 x86 - $($Item.Name)";"Name"="Microsoft Office 2016 x86 - $($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Office2016x86

			$Expression = @"
SELECT path,filename,extension,version FROM CIM_DataFile where path="\\Program Files\\Microsoft Office\\Office16\\" AND filename="$($Item.File)" AND extension="exe" AND version>="16" AND version<"17"
"@
			$Office2016x64 = @{"Expression"=@($Expression);"Description"="Microsoft Office 2016 x64 - $($Item.Name)";"Name"="Microsoft Office 2016 x64 - $($Item.Name)";"Namespace"="ROOT\CIMV2";}
			$Filters += $Office2016x64

		}

		$Expression = @"
SELECT * from Win32_Software where displayname like "Microsoft Office%2013%"
"@
		$Office2013x86System = @{"Expression"=@($Expression);"Description"="Microsoft Office 2013 x86 - System";"Name"="Microsoft Office 2013 x86 - System";"Namespace"="ROOT\CIMV2";}
		$Filters += $Office2013x86System

		$Expression = @"
SELECT * from Win32_Software64 where displayname like "Microsoft Office%2013%"
"@
		$Office2013x64System = @{"Expression"=@($Expression);"Description"="Microsoft Office 2013 x64 - System";"Name"="Microsoft Office 2013 x64 - System";"Namespace"="ROOT\CIMV2";}
		$Filters += $Office2013x64System

		$Expression = @"
SELECT * from Win32_Software where displayname like "Microsoft Office%2016%"
"@
		$Office2016x86System = @{"Expression"=@($Expression);"Description"="Microsoft Office 2016 x86 - System";"Name"="Microsoft Office 2016 x86 - System";"Namespace"="ROOT\CIMV2";}
		$Filters += $Office2016x86System

		$Expression = @"
SELECT * from Win32_Software64 where displayname like "Microsoft Office%2016%"
"@
		$Office2016x64System = @{"Expression"=@($Expression);"Description"="Microsoft Office 2016 x64 - System";"Name"="Microsoft Office 2016 x64 - System";"Namespace"="ROOT\CIMV2";}
		$Filters += $Office2016x64System

		#endregion

#region Server Features

		$Expression = @"
SELECT * FROM Win32_OptionalFeature Where (Name = "IIS-WebServerRole" OR Name = "IIS-WebServer") AND InstallState = 1
"@
		$IIS = @{"Expression"=@($Expression);"Description"="IIS";"Name"="IIS";"Namespace"="ROOT\CIMV2";}	
		$Filters += $IIS

		$Expression = @"
SELECT * FROM Win32_OptionalFeature WHERE (Name = "DNS-Server-Tools" OR Name = "RSAT-AD-Tools-Feature" OR Name = "RSAT-ADDS-Tools-Feature" OR Name = "DirectoryServices-DomainController-Tools" OR Name = "DirectorySerrvices-AdministrativeCenter") AND InstallState = 1
"@
		$ADManagementSystem = @{"Expression"=@($Expression);"Description"="Active Directory Management System - Feature Query";"Name"="Active Directory Management System - Feature Query";"Namespace"="ROOT\CIMV2";}	
		$Filters += $ADManagementSystem

		$Expression = @"
SELECT * FROM Win32_Service WHERE Name = "WMSvc"
"@
		$WebManagementService=@{"Expression"=@($Expression);"Description"="IIS Web Management Service";"Name"="IIS Web Management Service";"Namespace"="ROOT\CIMV2";}
		$Filters += $WebManagementService

		$Expression = @"
SELECT * FROM Win32_ComputerSystem where DomainRole = 5
"@
		$PDC = @{"Expression"=@($Expression);"Description"="PDC Emulator";"Name"="PDC Emulator";"Namespace"="ROOT\CIMV2";}
		$Filters += $PDC

		$Expression = @"
SELECT * FROM win32_optionalfeature WHERE Name = "FailoverCluster-FullServer" AND InstallState = 1
"@
		$WSFC = @{"Expression"=@($Expression);"Description"="Windows Server Failover Cluster Feature";"Name"="Windows Server Failover Cluster Feature";"Namespace"="ROOT\CIMV2";}
		$Filters += $WSFC

		$Expression = @"
SELECT * FROM win32_optionalfeature WHERE Name = "FailoverCluster-FullServer" AND InstallState = 1
"@
		$Expression2 = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue = 1
"@

		$WSFCAD = @{"Expression"=@($Expression,$Expression2);"Description"="Windows Server Failover Cluster Feature AD";"Name"="Windows Server Failover Cluster Feature AD";"Namespace"="ROOT\CIMV2";}
		$Filters += $WSFCAD

		$Expression = @"
SELECT * FROM win32_optionalfeature WHERE Name = "FailoverCluster-FullServer" AND InstallState = 1
"@
		$Expression2 = @"
SELECT * FROM Win32_Environment WHERE Name = "isADManagementSystem" and VariableValue = 0
"@

		$WSFCNonAD = @{"Expression"=@($Expression,$Expression2);"Description"="Windows Server Failover Cluster Feature Non AD";"Name"="Windows Server Failover Cluster Feature Non AD";"Namespace"="ROOT\CIMV2";}
		$Filters += $WSFCNonAD

		$Expression = @"
SELECT * from win32_optionalfeature where name = "CertificateServices" AND installstate = 1
"@
		$CA = @{"Expression"=@($Expression);"Description"="Active Directory Certificate Services";"Name"="Active Directory Certificate Services";"Namespace"="ROOT\CIMV2";}
		$Filters += $CA

		$Expression = @"
SELECT * from win32_optionalfeature WHERE (name = "WebEnrollmentServices" AND installstate = 1)
"@
		$CAWebEnrollment = @{"Expression"=@($Expression);"Description"="Active Directory Certificate Services - CA Web Enrollment";"Name"="Active Directory Certificate Services - CA Web Enrollment";"Namespace"="ROOT\CIMV2";}
		$Filters += $CAWebEnrollment

#endregion

#region Software

		$Expression = @"
select * from win32_software64 where DisplayName like "%Java%7%" AND VersionMajor = 7
"@
		$JRE7x64 = @{"Expression"=@($Expression);"Description"="JRE 7 x64";"Name"="JRE 7 x64";"Namespace"="ROOT\CIMV2";}	
		$Filters += $JRE7x64

$Expression = @"
select * from win32_software where DisplayName like "%Java%7%" AND VersionMajor = 7
"@
		$JRE7x86 = @{"Expression"=@($Expression);"Description"="JRE 7 x86";"Name"="JRE 7 x86";"Namespace"="ROOT\CIMV2";}	
		$Filters += $JRE7x86

		$Expression = @"
select * from win32_software64 where DisplayName like "%Java%8%" AND VersionMajor = 8
"@
		$JRE8x64 = @{"Expression"=@($Expression);"Description"="JRE 8 x64";"Name"="JRE 8 x64";"Namespace"="ROOT\CIMV2";}	
		$Filters += $JRE8x64

$Expression = @"
select * from win32_software where DisplayName like "%Java%8%" AND VersionMajor = 8
"@
		$JRE8x86 = @{"Expression"=@($Expression);"Description"="JRE 8 x86";"Name"="JRE 8 x86";"Namespace"="ROOT\CIMV2";}	
		$Filters += $JRE8x86

#endregion

#endregion

		foreach ($Domain in $Domains) 
		{
			$Counter = 1
			foreach ($Filter in $Filters)
			{
				$Percent = ($Counter / $Filters.Length) * 100
				Write-Progress -Activity "Creating WMI Filters in $Domain domain." -PercentComplete $Percent -Status "$([System.Math]::Round($Percent, 2))% Complete: $Counter of $($Filters.Length)"

				$ExistingFilter = Get-WmiFilter -Name $Filter.Name
				$Queries = @()

				if ($ExistingFilter -ne $null)
				{
					# The msWMI-Parm2 property uses 6 semi-colon properties per filter statement, the first number is the number of statements
					[System.String[]]$Parts = $ExistingFilter."msWMI-Parm2".Split(";")
					[System.Int32]$Count = [System.Int32]::Parse($Parts[0])

					for ($i = 1; $i -lt ($Count * 6); $i += 6)
					{
						$Queries += $Parts[$i + 5]
					}
				}

				if ((Compare-Object -ReferenceObject $Filter.Expression -DifferenceObject $Queries) -ne $null)
				{
					Write-Verbose -Message "Adding filter $($Filter.Name) with Expression $($Filter.Expression)"
					$Output += New-GPOWmiFilter -Name $Filter.Name -Description $Filter.Description -Expression $Filter.Expression -Domain $Domain -Namespace $Filter.Namespace -PassThru -WithReplace:$WithReplace @CredSplat
				}
				else
				{
					Write-Verbose -Message "The filter $($Filter.Name) already exists with the same expression."
				}

				$Counter++
			}

			Write-Progress -Completed -Activity "Creating WMI Filters in $Domain domain."
		}

		if ($PassThru) 
		{
			Write-Output -InputObject $Output
		}
	}

	End {
	}
}

Function New-GPOWmiFilter {
	<#
		.SYNOPSIS
			Creates a new WMI filter.

		.DESCRIPTION
			The cmdlet takes in the WMI filter properties and produces a usable WMI filter.

		.PARAMETER Name
			The WMI filter name.

		.PARAMETER Expression
			The expressions to evaluate in the filter, can be multiple WMI queries for a single filter.

		.PARAMETER Namespace
			A dynamically generated parameter of the available WMI namespaces. Defaults to ROOT\CIMV2.

		.PARAMETER Description
			The WMI filter description. This defaults to the WMI Filter Name.

		.PARAMETER Domain
			The domain the WMI filter is being created in, defaults to the domain of the logged on user.

		.PARAMETER Author
			The author creating the WMI filter, defaults to the current user.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.PARAMETER WithReplace
			If a WMI filter exists with the same name, the WMI query expression is updated.

		.PARAMETER PassThru
			Determines whether to return the new WMI filter object.

		.PARAMETER CimSession
			Specifies the CIM session to use for this cmdlet. Enter a variable that contains the CIM session or a command that creates or gets the CIM session, such as the New-CimSession or Get-CimSession cmdlets. For more information, see about_CimSessions.

        .EXAMPLE
			New-GPOWmiFilter -Name "Windows Server 2012 R2" -Expression @("Select * From Win32_OperatingSystem Where Version like '6.3%' and ProductType != 1") 

			Creates a WMI filter to target Windows Server 2012 R2.

		.INPUTS
			System.Object

		.OUTPUTS
			None or Microsoft.ActiveDirectory.Management.ADObject

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/30/2017
	#>
	[CmdletBinding(DefaultParameterSetName="Default")]
	[OutputType([Microsoft.ActiveDirectory.Management.ADObject])]
	Param
    (
        [Parameter(Mandatory = $true, Position = 0, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [System.String]$Name,

        [Parameter(Mandatory = $true, Position = 1, ParameterSetName = "Default")]
		[ValidateNotNull()]
        [System.String[]]$Expression,

        [Parameter(Mandatory = $false, Position = 3, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [System.String]$Description = [System.String]::Empty,

        [Parameter(Mandatory = $false, Position = 4, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [System.String]$Domain = [System.String]::Empty,

        [Parameter(Mandatory=$false, Position = 5, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [System.String]$Author = [System.String]::Empty,

		[Parameter()]
		[Switch]$WithReplace,

		[Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true, ParameterSetName = "InputObject")]
		[ValidateNotNull()]
		[System.Object]$InputObject,

        [Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter()]
        [System.Management.Automation.SwitchParameter]$PassThru,

		[Parameter()]
		[ValidateNotNull()]
        [Microsoft.Management.Infrastructure.CimSession]$CimSession = $null
    )

    DynamicParam 
    {
        # Create the dictionary 
        $RuntimeParameterDictionary = New-Object -TypeName System.Management.Automation.RuntimeDefinedParameterDictionary

		$ArraySet = Get-CimInstance -ClassName __Namespace -Namespace "ROOT" | Select-Object -ExpandProperty Name | ForEach-Object {return "ROOT\" + $_} 
		New-DynamicParameter -Name "Namespace" -Type ([System.String]) -Position 2 -ParameterSets @("Default") -ValidateSet $ArraySet -RuntimeParameterDictionary $RuntimeParameterDictionary | Out-Null

        return $RuntimeParameterDictionary
    }

    Begin {
	}

    Process
    {		
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ($CimSession -eq $null)
        {
            $CimSession = New-CimSession
        }

		if ($PSCmdlet.ParameterSetName -eq "InputObject")
		{
			$Author = $InputObject.Author
			$Expression = $InputObject.Expression
			$Domain = $InputObject.Domain
			$Namespace = $InputObject.Namespace
			$Name = $InputObject.Name
			$Description = $InputObject.Description
		}

        if ($Expression.Count -eq 0)
        {
			throw [System.ArgumentException]("At least one Expression Method is required to create a WMI Filter.")
        }

        if ([System.String]::IsNullOrEmpty($Domain))
        {
            $Domain = $env:USERDOMAIN
        }

		[Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Identity $Domain @CredSplat

        $DefaultNamingContext = $ADDomain.DistinguishedName

		$Server = [System.String]::Empty

		if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem) 
		{
			$Role = Get-CimInstance -Class Win32_OperatingSystem -Property ProductType -CimSession $CimSession | Select-Object -ExpandProperty ProductType

			if ($Role -eq 2) 
			{
				$Server = $env:COMPUTERNAME
			}
		}

		if ([System.String]::IsNullOrEmpty($Server)) 
		{
			$ContextType = [System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Domain
			$Context = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext($ContextType, $ADDomain.DnsRoot)
			$Server = ([System.DirectoryServices.ActiveDirectory.DomainController]::FindOne($Context)).Name
		}

        if ([System.String]::IsNullOrEmpty($PSBoundParameters.Namespace))
        {
            $Namespace = "ROOT\CIMv2"
        }
		else {
			$Namespace = $PSBoundParameters.Namespace
		}
 
        if (![System.String]::IsNullOrEmpty($Author))
        {
            $msWMIAuthor = $Author
        }
        else
        {
			try 
			{
				$User = Get-ADUser $env:USERNAME -ErrorAction SilentlyContinue @CredSplat

				if ($User -ne $null)
				{
					if (![System.String]::IsNullOrEmpty($User.UserPrincipalName)) 
					{
						$msWMIAuthor = $User.UserPrincipalName
					}
					else 
					{
						$msWMIAuthor = $User.SamAccountName
					}
				}
				else
				{
					$msWMIAuthor = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
				}
			}
			catch [Exception] 
			{
				$msWMIAuthor = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
			}
        }

		if ([System.String]::IsNullOrEmpty($Description)) 
		{
			$Description = $Name
		}

		$msWMIParm2 = $Expression.Count.ToString() + ";"

        foreach($Exp in $Expression)
        {
            $msWMIParm2 += "3;10;$($Exp.Length);WQL;$Namespace;$Exp;"
        }

		$msWMICreationDate = (Get-Date).ToUniversalTime().ToString("yyyyMMddhhmmss.ffffff-000")
		$msWMIChangeDate = $msWMICreationDate

		$Replaced = $false

		if ($WithReplace) 
		{
			$Filter = Get-ADObject -Filter {(objectClass -eq "msWMI-SOM") -and (msWMI-Name -eq $Name)} -Server $Server @CredSplat
			
			if ($Filter -ne $null) 
			{
				$Filter = $Filter | Select-Object -First 1

				$ADObject = Set-ADObject -Identity $Filter.DistinguishedName -Replace @{"msWMI-Parm2"=$msWMIParm2;"msWMI-ChangeDate"=$msWMIChangeDate} -Server $Server -PassThru @CredSplat
				$Replaced = $true
			}
		}

		if ($Replaced -eq $false) 
		{			
			$WMIGUID = "{" + ([System.Guid]::NewGuid().ToString()) + "}"
			$msWMIParm1 = $Description
       
			$Attr = @{
				"msWMI-Name" = $Name;
				"msWMI-Parm1" = $msWMIParm1;
				"msWMI-Parm2" = $msWMIParm2;
				"msWMI-Author" = $msWMIAuthor;
				"msWMI-ID"= $WMIGUID;
				"instanceType" = 4;
				"showInAdvancedViewOnly" = "TRUE";
				"msWMI-ChangeDate" = $msWMICreationDate; 
				"msWMI-CreationDate" = $msWMICreationDate
			}

			$WMIPath = "CN=SOM,CN=WMIPolicy,CN=System,$DefaultNamingContext"

			$ADObject = New-ADObject -Name $WMIGUID -Type "msWMI-Som" -Server $Server -Path $WMIPath -OtherAttributes $Attr -PassThru @CredSplat
		}

		if ($PassThru)
        {
            Write-Output -InputObject $ADObject
        }
    }

    End {
    }
}

Function Set-PDCEmulatorSrvRecords {
	<#
		.SYNOPSIS
			Changes the PDC Emulator Srv DNS Records for every domain in the forest.

		.DESCRIPTION
			The cmdlet defaults to reducing the priority and increasing the weight of the PDC Emulator in every domain so that it does not process logons.

		.PARAMETER Priority
			The priority to set on the DNS Srv Records for each PDC.

		.PARAMETER Weight
			The weight to set on the DNS Srv Records for each PDC.

		.PARAMETER RestartServer
			Indicate whether to restart the server in order to complete the change.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

			The user must have ENTERPRISE ADMIN privileges to connect to each PDC Emulator in each domain.

		.PARAMETER PassThru
			Returns an object that represents the updated dns records for each PDC Emulator.

        .EXAMPLE
			Set-PDCEmulatorSrvRecords
			
			Sets the priority to 200 and weight to 25.

		.EXAMPLE
			Set-PDCEmulatorSrvRecords -Priority 150 -Weight 20
			
			Sets the priority to 150 and weight to 20.

		.EXAMPLE
			Set-PDCEmulatorSrvRecords -RestartServer
			
			Sets the priority to 200 and weight to 25 and restarts the server immediately to implement the change.

		.INPUTS
			None

		.OUTPUTS
			System.Management.Automation.PSCustomObject[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param
	(
		[Parameter(Position = 0)]
		[System.Int32]$Priority = 200,

		[Parameter(Position = 1)]
		[System.Int32]$Weight = 25,

		[Parameter(Position = 2)]
		[System.Boolean]$RestartServer = $false,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[Switch]$PassThru
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Forest = Get-ADForest -Current LoggedOnUser @CredSplat
		$Domains = $Forest.Domains

		foreach ($Domain in $Domains)
		{
			Write-Verbose -Message "Setting SRV records in domain $Domain"

			$PDCEmulator = Get-ADDomain -Identity $Domain @CredSplat | Select-Object -ExpandProperty PDCEmulator

			Write-Verbose -Message "Identified PDC Emulator as $PDCEmulator"

			$Result = Invoke-Command -ComputerName $PDCEmulator -ScriptBlock {
				Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters -Name "LdapSrvPriority" -Value $args[0]
				Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters -Name "LdapSrvWeight" -Value $args[1]

				$SrvPriority = Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters -Name "LdapSrvPriority" | Select-Object -ExpandProperty LdapSrvPriority
				$SrvWeight = Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters -Name "LdapSrvWeight" | Select-Object -ExpandProperty LdapSrvWeight

				Write-Output -InputObject (New-Object -TypeName PSCustomObject -Property @{"LdapSrvPriority" = $SrvPriority; "LdapSrvWeight" = $SrvWeight})
			} -ArgumentList @($Priority,$Weight) @CredSplat

			if ($RestartServer)
			{
				Write-Verbose -Object "Restarting $PDCEmulator now."
				Restart-Computer -ComputerName $PDCEmulator -Wait -Credential @CredSplat
			}
			else
			{
				Write-Warning -Message "The change will not take effect until $PDCEmulator is restarted."
			}

			if ($PassThru) 
			{
				Write-Output -InputObject (New-Object -TypeName PSCustomObject -Property @{"Domain" = $Domain; "PDC Emulator" = $PDCEmulator; "LdapSrvPriority" = $Result.LdapSrvPriority; "LdapSrvWeight" = $Result.LdapSrvWeight})
			}     
		}
	}

	End {   
	}
}

Function Start-SDProp {
	<#
		.SYNOPSIS
			Runs the SDProp process immediately in the current domain.

		.DESCRIPTION
			The function sets the runProtectAdminGroupsTask on the RootDSE object to 1 and runs SDProp.

        .EXAMPLE
			Start-SDProp

			Launches the SDProp process.

		.INPUTS
			None

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 12/5/2015
	#>
	
	[CmdletBinding()]
	[OutputType()]
	Param()

	Begin {}

	Process{
		$RootDSE = [ADSI]"LDAP://RootDSE"
		$RootDSE.Put("runProtectAdminGroupsTask", 1)
		$RootDSE.SetInfo()
	}

	End {}
}

Function Set-SDPropSchedule {
    <#
		.SYNOPSIS
			Sets the schedule that the SDProp process runs.

		.DESCRIPTION
			The cmdlet sets the AdminSDProtectFrequency registry key value with the desired schedule in seconds. The cmdlet must be run on the PDC Emulator for it to be effective.

			The cmdlet requires confirmation because of the impact of the change.

		.PARAMETER Seconds
			The number of seconds in between SDProp execution tasks. This can be from 60 seconds (1 minute) to 7200 seconds (2 hours). Setting this value less than
			the default of 3600 seconds is not recommended for performance reasons.

		.PARAMETER FindPDCEmulator
			If this cmdlet is not being run on the PDC emulator for the domain, you can specify this parameter to find the PDC emulator in the domain and execute the change
			on that server.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

			The credential is used to connect to a remote computer if the FindPDCEmulator parameter is specified. If the cmdlet is being run locally, this parameter is ignored.

		.PARAMETER Domain
			The domain to execute the schedule update on. If this is not specified, it defaults to the domain of the current user.

        .EXAMPLE
			Set-SDPropSchedule -Seconds 5400

			Sets the schedule for the SDProp task to run every 5400 seconds (90 minutes).

		.EXAMPLE
			Set-SDPropSchedule -Seconds 5400 -FindPDCEmulator -Credential (Get-Credential)

			Sets the schedule for the SDProp task to run every 5400 seconds (90 minutes) on the PDC emulator discovered for the current user's domain.

		.INPUTS
			System.Int32

		.OUTPUTS
			System.Management.Automation.PSCustomObject

			Returns a custom object that contains the updated registry property.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/30/2017
	#>
	[CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = "High")]
	[OutputType([System.Management.Automation.PSCustomObject])]
	Param(
		[Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
		[ValidateRange(60, 7200)]
		[System.Int32]$Seconds,

		[Parameter(ParameterSetName = "Find")]
		[Switch]$FindPDCEmulator,

		[Parameter(ParameterSetName = "Find")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[Switch]$Force
	)

	Begin {
		Function Set-Value {
			[CmdletBinding()]
			Param(
				[Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
				[ValidateRange(60, 7200)]
				[System.Int32]$Seconds,

				[Parameter(Position = 1)]
				[ValidateNotNull()]
				[System.Management.Automation.Credential()]
				[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

				[Parameter(Position = 2)]
				[Microsoft.Management.Infrastructure.CimSession]$CimSession
			)

			Begin {
			}

			Process {
				$CredSplat = @{}

				if ($Credential -ne [PSCredential]::Empty)
				{
					$CredSplat["Credential"] = $Credential
				}

				if ($CimSession -eq $null)
				{
					$CimSession = New-CimSession
				}

				$Path = "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS\Parameters"
				$Key = "AdminSDProtectFrequency"
				
				$Role = Get-CimInstance -ClassName Win32_ComputerSystem -Property DomainRole -Namespace "root\cimv2" -CimSession $CimSession -ErrorAction Stop | Select-Object -ExpandProperty DomainRole

				if ($Role -ne 5)
				{
					Write-Warning -Message "This computer is not the PDC emulator, this cmdlet will not run."
				}
				else
				{
					if (-not (Test-Path -Path $Path))
					{
						Write-Verbose -Message "Creating registry key $Path"
						New-Item -Path $Path -ErrorAction Stop @CredSplat | Out-Null
					}

					New-ItemProperty -Path $Path -Name $Key -Value $Seconds -PropertyType DWORD -Force @CredSplat
				}
			}
			 
			End {
			}
		}
	}

	Process {		

		$Path = "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS\Parameters"
		$Key = "AdminSDProtectFrequency"

		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$ConfirmMessage = "Set frequency to $Seconds seconds."
		$WhatIfDescription = "Changed frequency to $Seconds seconds."
		$ConfirmCaption = "Set SDProp Schedule"

		if ($Seconds -lt 3600)
		{
			$ConfirmMessage = "Setting the frequency to less than 3600 seconds (1 hour) could have potential LSASS performance ramifications in a large environment, i.e. doing this could cause your DCs processor to spike to very high sustained levels and drastically hurt you."
		}

		if ($Force -or $PSCmdlet.ShouldProcess($WhatIfDescription, $ConfirmMessage, $ConfirmCaption))
		{
			if ($FindPDCEmulator)
			{
				if ([System.String]::IsNullOrEmpty($Domain))
				{
					$Domain = $env:USERDOMAIN
				}

				[System.String]$PDC = Get-ADDomain -Identity $Domain @CredSplat | Select-Object -ExpandProperty PDCEmulator
				
				Invoke-Command -ComputerName $PDC -ScriptBlock ${function:Set-Value} -ArgumentList @($Seconds) @CredSplat
			}
			else
			{
				Set-Value -Seconds $Seconds @CredSplat
			}
		}
	}

	End {
	}
}

Function Grant-SPNWriteOnProtectedADObjects {
	<#
		.SYNOPSIS
			The NETWORK SERVICE principal attempts to register SPNs on servers, most commonly WSMAN, but is unable to due to default permissions. 
			Explicity setting an Access Control Entry (ACE) on the computer object will only temporarily work in some cases because the AdminSDHolder ACL does not include 
			the NETWORK SERVICE principal and the recurring SDProp task replaces protected objects' ACLs with the ACL on the AdminSDHolder object. Domain controllers are the 
			typical example of computer objects affected by this security design. This cmdlet sets the permissions on the AdminSDHolder object so that updated ACL entries
			on protected objects, like domain controllers, are not overwritten.
			
		.DESCRIPTION
			This cmdlet runs against each domain in the current forest and Enterprise Admin privileges are required.

			The Grant-SPNWriteOnProtectedADObjects cmdlet adds the NETWORK SERVICE principal with the "Validated Write to Service Principal Name" right to the AdminSDHolder
			container so that protected objects do not have their ACLs overwritten when they are fixed to resolve EventId 10154

			The error that is received on a protected computer/server will look like the following if this command needs to be run:

			-----------

			The WinRM service failed to create the following SPNs: WSMAN/servername.fqdn; WSMAN/servername 
			
			Additional Data 
			The error received was 1355: %%1355.
			User Action 
			The SPN can be created by an administrator using setspn.exe utility.

			-----------

			A background process, Security Descriptor Propagator Update (SDProp), on the PDC emulator runs every 60 minutes (by default) and compares the ACL of the AdminSDHolder 
			object with the ACL of the protected users, group and computers. If there are any differences it overwrites them.

		.PARAMETER IncludeDomainControllers
			The updated ACL entries are also added to the domain controllers in the defined domain.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Grant-SPNWriteOnProtectedADObjects

	        Configures the permissions on the AdminSDHolder object in each domain of the current forest. 

		.EXAMPLE
			Grant-SPNWriteOnProtectedADObjects -IncludeDomainControllers

	        Configures the permissions on the AdminSDHolder object in each domain of the current forest. It also enables the NETWORK SERVICE principal to write SPNs
			on domain controller objects.

		.INPUTS
			None

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter()]
		[Switch]$IncludeDomainControllers,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin{
	}

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if (Test-IsEnterpriseAdmin @CredSplat)
		{
			[Microsoft.ActiveDirectory.Management.ADForest]$Forest = Get-ADForest -Current LoggedOnUser @CredSplat
			[System.String]$ForestDN = (Get-ADDomain -Identity ($Forest.RootDomain) @CredSplat).DistinguishedName
			[System.String[]]$Domains = $Forest.Domains

			foreach ($Domain in $Domains)
			{
				[System.Security.Principal.SecurityIdentifier]$DomainSID = Get-ADDomain -Identity $Domain @CredSplat | Select-Object -ExpandProperty DomainSID

				#f3a64788-5306-11d1-a9c5-0000f80367c1
				$ExtendedRightGuid = Get-ADObject -Identity ("CN=Validated-SPN,CN=Extended-Rights,CN=Configuration," + $ForestDN) -Properties RightsGUID @CredSplat | Select-Object -ExpandProperty RightsGUID
				[System.Security.Principal.SecurityIdentifier]$NetworkService = New-Object System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::NetworkServiceSid, $DomainSID)

				$Ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule(
					$NetworkService, 
					[System.DirectoryServices.ActiveDirectoryRights]::Self, 
					[System.Security.AccessControl.AccessControlType]::Allow, 
					$ExtendedRightGuid, 
					[System.DirectoryServices.ActiveDirectorySecurityInheritance]::None
				)

				[System.DirectoryServices.ActiveDirectoryAccessRule[]] $Rules = @($Ace)

				Set-ADObjectAcl -Rules $Rules -ObjectDN "CN=AdminSDHolder,CN=System,$($Domain.Replace(".","DC="))" @CredSplat
				
				if ($IncludeDomainControllers)
				{
					$Context = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(
						[System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Domain,
						$Domain)

					[System.DirectoryServices.ActiveDirectory.DomainControllerCollection]$DomainControllers = [System.DirectoryServices.ActiveDirectory.DomainController]::FindAll($Context)

					foreach ($DomainController in $DomainControllers)
					{
						$Path = Get-ADDomainController -Identity $DomainController.Name -Server $DomainController.Name | Select-Object -ExpandProperty ComputerObjectDN

						Set-ADObjectAcl -Rules $Rules -ObjectDN $Path 
					}
				}
			}
		}
		else
		{
			Write-Error -Message "Current user is not an Enterprise Admin, run the command again with Enterprise Admin credentials."
			throw [System.UnauthorizedAccessException]("Current user is not an Enterprise Admin, run the command again with Enterprise Admin credentials.")
		}
	}
	
	End {
	}
}

Function Set-ADObjectAcl {
	<#
		.SYNOPSIS
			Sets permissions on an Active Directory object.

		.DESCRIPTION
			Will set permissions on an Active Directory object with the provided rule set and Object CN. ACLs for security principals that are defined as part of
			the rule set provided will be replaced with the updated rules. Other ACLs rules will not be affected unless the Replace switch is defined.

        .EXAMPLE
			Set-ADObjectAcl -Domain contoso.com -ObjectCN "CN=AdminSDHolder,CN=System" -Rules $Rules

			Adds permissions to the AdminSDHolder container in the contoso.com domain with the ACL rules provided.

		.EXAMPLE
			Set-ADObjectAcl -ObjectDN "CN=AdminSDHolder,CN=System,DC=contso,DC=com" -Rules $Rules -Replace

			Sets permissions on the AdminSDHolder container in the contoso.com domain with the ACL rules provided. All existing ACL entries are replaced
			with the provided rules.

		.PARAMETER Domain
			The domain in which to configure the object's ACL.

		.PARAMETER ObjectCN
			The CN of the object being configured up to the domain part of the DN. This can be an empty string to configure the domain object.

		.PARAMETER ObjectDN
			The DistinguishedName of the object being configured.

		.PARAMETER Rules
			An array of Active Directory Access Rules

		.PARAMETER ReplaceForExistingPrincipal
			Indicates that existing ACL entries that have a common security principal as a new defined rule should be replaced with the newer rule. If the Replace
			parameter is specified, this parameter is ignored.

		.PARAMETER Replace
			Indicates that all ACL entries on the object should be replaced with the provided rules. If this is not specified, the provided rules are only
			added to the existing rules.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.INPUTS
			System.DirectoryServices.ActiveDirectoryAccessRule[]

		.OUTPUTS
			None

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/30/2017
	#>
	
	[CmdletBinding(DefaultParameterSetName = "DN")]
	[OutputType()]
    Param 
    (
        [Parameter(Mandatory = $true, Position = 0, ParameterSetName = "CN")]
        [AllowEmptyString()]
        [System.String]$ObjectCN,

		[Parameter(Position = 1, ParameterSetName = "CN")]
		[ValidateNotNullOrEmpty()]
        [System.String]$Domain,

		[Parameter(Position = 0, Mandatory = $true, ParameterSetName = "DN")]
		[ValidateNotNullOrEmpty()]
		[System.String]$ObjectDN,

        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
		[ValidateNotNull()]
        [System.DirectoryServices.ActiveDirectoryAccessRule[]]$Rules,

		[Parameter()]
		[Switch]$Replace,

		[Parameter()]
		[Switch]$ReplaceForExistingPrincipal,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
    )

    Begin {   
    }

    Process
    {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ([System.String]::IsNullOrEmpty($Domain))
		{
			$Domain = $env:USERDOMAIN
		}
		
		[Microsoft.ActiveDirectory.Management.ADDomain]$Temp = Get-ADDomain -Current LoggedOnUser -ErrorAction Stop @CredSplat
		$DomainDN = $Temp.DistinguishedName
		$Domain = $Temp.DNSRoot

        $DC = Get-ADDomainController -DomainName $Domain -Discover
		[System.String[]]$Drives = Get-PSDrive | Select-Object -ExpandProperty Name

        if ($DC -ne $null)
        {
            if (Test-Connection -ComputerName "$($DC.Name).$($DC.Domain)" -Count 1)
            {
                $TempDrive = "tempdrive"

                if ($Drives.Contains($TempDrive))
                {
                    Write-Host "An existing PSDrive exists with name $TempDrive, temporarily removing" -ForegroundColor Yellow
                    $OldDrive = Get-PSDrive -Name $TempDrive
                    Remove-PSDrive -Name $TempDrive
                }

                $Drive = New-PSDrive -Name $TempDrive -Root "" -PSProvider ActiveDirectory -Server "$($DC.Name).$($DC.Domain)" @CredSplat

				Push-Location -Path "$Drive`:\"

				switch ($PSCmdlet.ParameterSetName)
				{
					"CN" {
						if ([System.String]::IsNullOrEmpty($ObjectCN))
						{
							$ObjectDN = $DomainDN
						}
						else
						{
							$ObjectDN = $ObjectCN + "," + $DN
						}
						break
					}
					"DN" {
						#Do nothing
						break
					}
					default {
						throw "Could not determine parameter set name."
					}
				}

                [System.String[]]$Paths = @()

				#Make sure the object exists
                $ObjectToChange = Get-ADObject -Identity $ObjectDN -Server "$($DC.Name).$($DC.Domain)" -ErrorAction Stop @CredSplat
                $Path = $Drive.Name + ":" + $ObjectDN

				Write-Verbose -Message "Modifying ACL on $Path."

                try
                {
                    $Acl = Get-Acl -Path $Path

                    if ($Acl -ne $null)
                    {
						if ($Replace)
						{
							$OldAcls = $Acl.Access
						}
						elseif ($ReplaceForExistingPrincipal)
						{
							$OldAcls = $Acl.Access | Where-Object {$Rules.IdentityReference -eq  $_.IdentityReference.Translate([System.Security.Principal.SecurityIdentifier])}
						}
						else
						{
							$OldAcls = @()
						}

                        foreach ($Rule in $OldAcls)
                        {
                            $Acl.RemoveAccessRule($Rule) | Out-Null
                        }

                        foreach ($Rule in $Rules)
                        {
                            $Acl.AddAccessRule($Rule) | Out-Null
                        }

                        $NewAcl = Set-Acl -Path $Path -AclObject $Acl -Passthru
                    
						Write-Host -Object $Domain -ForegroundColor DarkRed -BackgroundColor White
						Write-Host -Object ($Path.Substring($Path.IndexOf(":") + 1)) -ForegroundColor DarkRed -BackgroundColor White
						Write-Host -Object ($NewAcl.Access | Format-List | Out-String)
						Write-Host -Object ""
                    }
                    else
                    {
                        Write-Warning "Could not retrieve the ACL for $Path"
                    }
                }
                catch [System.Exception]
                {
                    Write-Warning -Message $_.Exception.Message
                }

				Pop-Location

                Remove-PSDrive $Drive

                if ($OldDrive)
                {
                    Write-Host "Recreating original PSDrive" -ForegroundColor Yellow
                    New-PSDrive -Name $OldDrive.Name -PSProvider $OldDrive.Provider -Root $OldDrive.Root | Out-Null
                    Remove-Variable -Name "OldDrive"
                }
            }
            else
            {
                Write-Warning -Message "Could not contact domain controller $($DC.Name).$($DC.Domain)."
            }
        }
		else
		{
			Write-Warning -Message "Could not locate a domain controller in $Domain."
		}
    }

    End {}
}

Function Get-KerberosDelegationInformation {
	<#
		.SYNOPSIS
			Gets Kerberos delegation information for a delegated server and its target.

		.DESCRIPTION
			The cmdlet retrieves the delegation information and UAC information for delegation permissions. It also retrieves the registered SPNs for the target servers.

		.PARAMETER DelegatedServer
			The server that is granted Kerberos delegation permissions.

		.PARAMETER TargetServer
			The server that is the target of the delegation.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Get-KerberosDelegationInformation -DelegatedServer WebServer1 -TargetServer AppServer1

			Gets the delegation information for WebServer1 to AppServer1.

		.INPUTS
			None

		.OUTPUTS
			System.Management.Automation.PSCustomObject

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>

	[CmdletBinding()]
	[OutputType([System.Management.Automation.PSCustomObject])]
	Param(
		[Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$DelegatedServer,

		[Parameter(Position = 1, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$TargetServer,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Delegation = Get-ADComputer -Identity $DelegatedServer -Properties msDS-AllowedToDelegateTo,UserAccountControl @CredSplat | Select-Object -Property msDS-AllowedToDelegateTo,UserAccountControl
		[System.String[]]$SPNs = (Get-ADComputer -Identity $TargetServer -Properties ServicePrincipalName @CredSplat | Select-Object -ExpandProperty ServicePrincipalName).Split("`n")
		
		$Matches = @()
		foreach ($Value in $script:UACValues) 
		{
			#Perform bitwise and to compare the current UAC against each possible value and record matches
			if ($Delegation.UserAccountControl -band [System.Convert]::ToInt64($Value.Key, 16)) 
			{
				$Matches += $Value
			}
		}

		Write-Output -InputObject ([PSCustomObject]@{DelegatedServer=$DelegatedServer;AllowedToDelegateTo=$Delegation.'msDS-AllowedToDelegateTo';UAC=$Matches;TargetServer=$TargetServer;TargetSPNs=$SPNs})
	}

	End {
	}
}

Function Test-IsEnterpriseAdmin {
	<#
		.SYNOPSIS
			Tests if a user is a member of the Enterprise Admins group.

		.DESCRIPTION
			The Test-IsEnterpriseAdmin returns true if the user is in the group and false otherwise.

        .EXAMPLE
			Test-IsEnterpriseAdmin

	        Determines if the user credentials being used to run the cmdlet have Enterprise Admin privileges.
		
		.EXAMPLE
			Test-IsEnterpriseAdmin -UserName "John Smith"

			Determines if the user John Smith has Enterprise Admin privileges.

		.EXAMPLE
			Test-IsEnterpriseAdmin -Credential (Get-Credential)
			
			Determines if the entered user credentials have Enterprise Admin privileges.

		.PARAMETER UserName
			The user to test the group membership on. If no user name is specified, the cmdlet runs against the current WindowsIdentity Principal.

		.PARAMETER Credential
			The PSCredential to use to test if the user has Enterprise Admin credentials. These credentials are not used to execute commands.

		.INPUTS
			System.Management.Automation.PSCredential

			System.String

		.OUTPUTS
			System.Boolean

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding(DefaultParameterSetName="Username")]
	[OutputType([System.Boolean])]
	Param (
		[Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Username")]
		[ValidateNotNullOrEmpty()]
		[System.String]$UserName = [System.String]::Empty,

		[Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Credential")]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process 
	{
		if ($PSCmdlet.ParameterSetName -eq "Credential")
		{
			$UserName = $Credential.UserName
		}

		$Details = Get-ADPrincipalDetails -Identity $UserName

		Write-Output -InputObject $Details.EnterpriseAdmin
	}

	End {		
	}
}

Function Test-IsEnterpriseOrDomainAdmin {
	<#
		.SYNOPSIS
			Tests whether the current user or provided credential is a Domain Admin or Enterprise Admin.

		.DESCRIPTION
			The Test-IsEnterpriseOrDomainAdmin returns true if the user is in the group and false otherwise.

        .EXAMPLE
			Test-IsEnterpriseOrDomainAdmin
	        
			Determines if the user credentials being used to run the cmdlet have Domain or Enterprise Admin privileges

		.EXAMPLE
			Test-IsEnterpriseOrDomainAdmin -Credential $Creds

			Determines if the credentials have Enterprise or Domain Admin privileges

		.PARAMETER UserName
			The user to test the group membership on. If no user name is specified, the cmdlet runs against WindowsIdentity Principal.

		.PARAMETER Credential
			The PSCredential to use to test if the user has Enterprise Admin credentials. These credentials are not used to execute commands.

		.PARAMETER Domain
			The domain to check for privileges in. This defaults to the current user's domain.

		.INPUTS
			System.Management.Automation.PSCredential

			System.String

		.OUTPUTS
			System.Boolean

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding(DefaultParameterSetName="Username")]
	[OutputType([System.Boolean])]
    Param
    (
        [Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Credential")]
		[ValidateNotNull()]
        [System.Management.Automation.Credential()]
        [System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Username")]

		[System.String]$Username = [System.String]::Empty,

		[Parameter(Position = 1)]
        [System.String]$Domain = [System.String]::Empty
    )

	Begin {
	}

	Process
	{		
		if ($PSCmdlet.ParameterSetName -eq "Credential")
		{
			$UserName = $Credential.UserName
		}

		$Details = Get-ADPrincipalDetails -Identity $UserName -Domain $Domain

		Write-Output -InputObject ($Details.DomainAdmin -or $Details.EnterpriseAdmin)
	}
	
	End {		
	}
}

Function Test-IsDomainAdmin {
	<#
		.SYNOPSIS
			Tests if a user is a member of the Domain Admins group.

		.DESCRIPTION
			The Test-IsDomainAdmin returns true if the user is in the Domain Admins group and false otherwise.

        .EXAMPLE
			Test-IsDomainAdmin

	        Determines if the user credentials being used to run the cmdlet has Domain Admin privileges.

		.EXAMPLE
			Test-IsDomainAdmin -UserName "John Smith"

			Determines if the user John Smith has Domain Admin privileges

		.PARAMETER UserName
			The user to test the group membership on. If no user name is specified, the cmdlet runs against the current WindowsIdentity Principal.

		.PARAMETER Credential
			The PSCredential to use to test if the user has Domain Admin credentials. These credentials are not used to execute commands.

		.PARAMETER Domain
			The domain to check for privileges in. This defaults to the logged on user's domain.

		.INPUTS
			System.Management.Automation.PSCredential
			
			System.String

		.OUTPUTS
			System.Boolean

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding(DefaultParameterSetName="Username")]
	Param (
		[Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Username")]
		[ValidateNotNullOrEmpty()]
		[System.String]$UserName = [System.String]::Empty,

		[Parameter(Position = 0, ValueFromPipeLine = $true, ParameterSetName = "Credential")]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [PSCredential]::Empty,

		[Parameter(Position = 1)]
        [System.String]$Domain
	)

	Begin {
	}

	Process 
	{
		if ($PSCmdlet.ParameterSetName -eq "Credential")
		{
			$UserName = $Credential.UserName
		}

		$Details = Get-ADPrincipalDetails -Identity $UserName -Domain $Domain

		Write-Output -InputObject $Details.DomainAdmin
	}

	End {		
	}
}

Function ConvertTo-ADObject {
    <#
		.SYNOPSIS
			Takes an identity and an optional domain and returns information about a matching AD object.

		.DESCRIPTION
			The cmdlet takes the identity and matches it against properties to include:
            
                -Name
                -SamAccountName
                -CN
                -DistinguishedName
                -Display Name
                -ObjectSID
                -ObjectGUID

            Only user, computer, group, and foreignSecurityPrincipal object types are searched and returned. If there are multiple matches to the identity
            value, only the first match is returned. Additionally, information about the object's domain and forest are also included in the return object.

		.EXAMPLE
			ConvertTo-ADObject -Identity "Domain Admins" -Domain contoso

            Gets information about the AD object in contoso that matches "Domain Admins"

		.PARAMETER Identity
            The identity to convert to an AD object. This is a string that is matched against AD object properties:

                -Name
                -SamAccountName
                -CN
                -DistinguishedName
                -Display Name
                -ObjectSID
                -ObjectGUID

            For user objects, the identity can be provided as a User Principal Name (UPN) or domain\username format. In these cases, the domain will be extracted
            from the identity and does not need to be specified. 

            If this parameter is not specified, the current windows identity principal is utilized, which could be a user or system account, which is translated to the corresponding
            computer object.

		.PARAMETER Domain
            Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter. If the identity parameter is specified, the current user domain is used. If the identity parameter is not specified, and the current windows identity is
            the system account, the local computer domain is used, otherwise the current user domain is used.

            If the Identity parameter is specified with a domain\username or UPN value, this parameter is ignored.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.INPUTS
			System.String

		.OUTPUTS
			System.Management.Automation.PSCustomObject

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>
    [CmdletBinding()]
	[OutputType([System.Management.Automation.PSCustomObject])]
    Param(
		[Parameter(Position = 0, ValueFromPipeLine = $true, Mandatory= $true)]
		[AllowEmptyString()]
		[System.String]$Identity = [System.String]::Empty,

		[Parameter(Position = 1)]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [PSCredential]::Empty
	)

    Begin {
    }

    Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

        if ([System.String]::IsNullOrEmpty($Identity))
        {
            #If the identity wasn't specified, then we'll use the current identity, there are two options, either it is the system or service
            #account, or it is a user

			[System.Security.Principal.WindowsIdentity]$Principal = [System.Security.Principal.WindowsIdentity]::GetCurrent()
			
            #NT AUTHORITY\SYSTEM is the name attribute for the system account
			if ($Principal.IsSystem) 
			{
				$Identity = $env:COMPUTERNAME
                
                Write-Verbose -Message "Current principal is the SYSTEM account for $Identity."
            }
            else
            {
                $Identity = $Principal.Name
            }
        }

        if ($Identity.IndexOf("\") -ne -1) 
		{
		    $TempDomain = $Identity.Substring(0, $Identity.IndexOf("\"))
			[Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Identity $TempDomain @CredSplat
			$Identity = $Identity.Substring($Identity.IndexOf("\") + 1)
		}
		#Identity is in a UPN format
		elseif ($Identity.IndexOf("@") -ne -1) 
		{
		    $Domain = $Identity.Substring($Identity.IndexOf("@") + 1)
			[Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Identity $Domain @CredSplat
			$Identity = $Identity.Substring(0, $Identity.IndexOf("@"))
		}
		#Identity has no domain defined
		else 
		{
		    if ([System.String]::IsNullOrEmpty($Domain))
			{
			    [Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Current LoggedOnUser @CredSplat
			}
			else
			{
			    [Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Identity $Domain @CredSplat
			}
		}

        Write-Verbose -Message "Finding details for $Identity in $($ADDomain.DNSRoot)."

        [Microsoft.ActiveDirectory.Management.ADObject]$ADObj = Get-ADObject -Filter { Name -eq $Identity -or SamAccountName -eq $Identity -or DisplayName -eq $Identity -or CN -eq $Identity -or DistinguishedName -eq $Identity -or ObjectSID -eq $Identity -or ObjectGUID -eq $Identity } `
            -Server $ADDomain.DNSRoot -Properties memberOf,msds-principalName,userAccountControl @CredSplat | Where-Object {$_.ObjectClass -in @("user", "computer", "group", "foreignSecurityPrincipal", "contact")} | Select-Object -First 1

        Write-Output -InputObject ([PSCustomObject]@{Identity = $ADObj; Domain = $ADDomain; Forest = (Get-ADDomain -Identity $ADDomain.Forest -Server $ADDomain.Forest @CredSplat) })
    }

    End {
    }
}

Function Get-ADGroupMembershipChangeSummary {
	<#
		.SYNOPSIS
			Finds all of the group membership changes in the logs on all of the domain controllers in a domain.

		.DESCRIPTION
			Finds all of the group membership changes in the logs on all of the domain controllers in a domain. It returns these logs in several formats that can be selected. The default output is a custom object.

		.PARAMETER DaysAgo
			Specifies how many days in the past the search should start.

		.PARAMETER Domain
			The domain to perform the search on. This defaults to the domain of the current user.

		.PARAMETER AsJson
			Returns the report as a Json string.

		.PARAMETER AsXml
			Returns the report as an Xml string.

		.PARAMETER AsHtml
			Returns the report as a custom formatted html document.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Get-ADGroupMembershipChangeSummary -DaysAgo 1 -Domain "contoso.com"

			Gets all of the group membership changes in the past day from contoso.com

		.INPUTS
			None

		.OUTPUTS
			System.String

                This is returned when AsJson, AsHtml, or AsXml are specified.

            System.Management.Automation.PSObject

                This is returned when no transform of the result is specified.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/4/2017
	#>

	[CmdletBinding(DefaultParameterSetName = "default")]
	[OutputType([System.String], [System.Management.Automation.PSObject])]
	Param(
		[Parameter(Position = 0)]
		[System.Int32]$DaysAgo = 1,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter(ParameterSetName="Json")]
		[Switch]$AsJson,

		[Parameter(ParameterSetName="Xml")]
		[Switch]$AsXml,

		[Parameter(ParameterSetName="Html")]
		[Switch]$AsHtml,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		if ($Domain -eq [System.String]::Empty)
		{
			$Domain = (Get-ADDomain -Current LoggedOnUser).DnsRoot
		}

		$Context = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Domain, $Domain)
		$Report = New-Object -TypeName PSObject -Property @{"Added To Domain Local Group"=@();"Removed From Domain Local Group"=@();"Added To Global Group"=@();"Removed From Global Group"=@();"Added To Universal Group"=@();"Removed From Universal Group"=@()}

		<#
			Event ID 636 & 4732 - Member added to domain local group
			Event ID 637 & 4733 - Member removed from domain local group
			Event ID 632 & 4728 - Member added to global group
			Event ID 633 & 4729 - Member removed from domain local group
			Event ID 660 & 4756 - Member added to universal group
			Event ID 661 & 4757 - Member removed from universal group
		#>
		$Count = 0
		[System.DirectoryServices.ActiveDirectory.DomainController]::FindAll($Context) | ForEach-Object {
			Write-Verbose -Message "Evaluating server $($_.Name)."
			$Count++

			[System.Version]$Version = [System.Environment]::OSVersion.Version
			[System.Decimal]$Version = [System.Decimal]::Parse("$($Version.Major).$($Version.Minor)")

			if ($Version -ge 6.1)
			{
				[System.Diagnostics.Eventing.Reader.EventLogRecord[]]$Events = Get-WinEvent -ComputerName $_.Name -FilterHashtable @{LogName=@("Security");ID=@(636,4732,637,4733,632,4728,633,4729,660,4756,661,4757);StartTime=(Get-Date).AddDays($DaysAgo * -1)} -ErrorAction SilentlyContinue @CredSplat

				if ($Events -ne $null -and $Events.Count -ge 1)
				{
					#Domain Local Groups
					$Report."Added To Domain Local Group" += $Events | Where-Object {$_.ID -eq 636 -or $_.ID -eq 4732} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message
					$Report."Removed From Domain Local Group" += $Events | Where-Object {$_.ID -eq 637 -or $_.ID -eq 4733} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message

					#Global Groups
					$Report."Added To Global Group" += $Events | Where-Object {$_.ID -eq 632 -or $_.ID -eq 4728} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message
					$Report."Removed From Global Group" += $Events | Where-Object {$_.ID -eq 633 -or $_.ID -eq 4729} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message

					#Universal Groups
					$Report."Added To Universal Group" += $Events | Where-Object {$_.ID -eq 660 -or $_.ID -eq 4756} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message
					$Report."Removed From Universal Group" += $Events | Where-Object {$_.ID -eq 661 -or $_.ID -eq 4757} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeCreated.DateTime} },Message
				}
				else
				{
					Write-Verbose -Message "No events found on $($_.Name)."
				}
			}
			else
			{
				[System.Diagnostics.EventLogEntry[]]$Events = Get-EventLog -LogName "Security" -ComputerName $_.Name -After ((Get-Date).AddDays($DaysAgo * -1)) -ErrorAction SilentlyContinue | Where-Object {$_.EventID -in @(636,4732,637,4733,632,4728,633,4729,660,4756,661,4757) } | Sort-Object -Descending -Property TimeGenerated

				if ($Events -ne $null -and $Events.Count -ge 1)
				{
					#Domain Local Groups
					$Report."Added To Domain Local Group" += $Events | Where-Object {$_.ID -eq 636 -or $_.ID -eq 4732} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message
					$Report."Removed From Domain Local Group" += $Events | Where-Object {$_.ID -eq 637 -or $_.ID -eq 4733} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message

					#Global Groups
					$Report."Added To Global Group" += $Events | Where-Object {$_.ID -eq 632 -or $_.ID -eq 4728} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message
					$Report."Removed From Global Group" += $Events | Where-Object {$_.ID -eq 633 -or $_.ID -eq 4729} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message

					#Universal Groups
					$Report."Added To Universal Group" += $Events | Where-Object {$_.ID -eq 660 -or $_.ID -eq 4756} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message
					$Report."Removed From Universal Group" += $Events | Where-Object {$_.ID -eq 661 -or $_.ID -eq 4757} | Select-Object -Property MachineName,@{Name="TimeCreated"; Expression ={$_.TimeGenerated} },Message
				}
				else
				{
					Write-Verbose -Message "No events found on $($_.Name)."
				}
			}
		}

		switch ($PSCmdlet.ParameterSetName) {
			"Json" {
				Write-Output -InputObject (ConvertTo-Json -InputObject $Report)
				break
			}
			"Xml" {
				Write-Output -InputObject (ConvertTo-Xml -InputObject $Report -Depth 2 -As String)
				break
			}
			"Html" {
				$Date = (Get-Date).ToString()

				$HtmlString = @"
<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width" />
		<title>Group Membership Change Report</title>
	</head>
    <style>
        .logtable {
            width:100%;
            table-layout:fixed;
            border:1px solid black;
        }

        .timecolumn {
            width:25%;
        }

        .messagecolumn {
            width:75%;
        }
        
        .logtable td {
            word-break:break-all;
            word-wrap:break-word;
            vertical-align:top;
			text-align:left;
        }

        .logtable th {
            text-align:left;
        }
    </style>
	<body style=`"width:900px;margin-left:auto;margin-right:auto;`">
        <div>
            Generated on $Date
        </div>
        <div>
			<div>
				<label style=`"margin:0px;`">Domain:</label><span style=`"margin-left:5px;`">$Domain</span>
			</div>
			<div>
				<label style=`"margin:0px;`">Number Of Domain Controllers:</label><span style=`"margin-left:5px;`">$Count</span>
			</div>
        </div>
        <div>
"@

				foreach ($Property in (Get-Member -InputObject $Report -MemberType NoteProperty))
				{
					$HtmlString += "<h2 style=`"text-align:center`">" + $Property.Name + "</h2>"

					$Grouping = $Report | Select-Object -ExpandProperty $Property.Name | Group-Object -Property MachineName     

					foreach($Group in $Grouping)
					{
						$HtmlString += "<h3 style=`"color:red;`">DOMAIN CONTROLLER: " + $Group.Name + "</h3><br />"
						$HtmlString += "<table class=`"logtable`"><thead><tr><th class=`"timecolumn`">Time Created</th><th class=`"messagecolumn`">Message</th></tr></thead><tbody>"

						foreach($LogEntry in $Group.Group)
						{
							$HtmlString += "<tr><td>" + $LogEntry.TimeCreated + "</td><td>" + $LogEntry.Message + "</td>"
						}

						$HtmlString += "</tbody></table>"
					}
				}

				$HtmlString += "</div></body></html>"

				Write-Output -InputObject $HtmlString
				break
			}
			default {
				Write-Output -InputObject $Report
				break
			}
		}
	}

	End {		
	}
}

Function Get-ADObjectPropertyChangeInfo {
	<#
		.SYNOPSIS
			Finds when a particular object's property was last modified and where the change took place. Then it searches the logs on the server.

		.DESCRIPTION
			The cmdlet finds out when an object's property was changed and what server it occured on so those logs can be searched.

		.PARAMETER Identity
			The identity of the group, user, computer, OU, or container to find information about. This can be the SAM Account Name, Display Name, Name, DN, or CN.

		.PARAMETER Property
			The property to search on to find when it was changed.

		.PARAMETER Domain
            Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter. If the identity parameter is specified, the current user domain is used. If the identity parameter is not specified, and the current windows identity is
            the system account, the local computer domain is used, otherwise the current user domain is used.

            If the Identity parameter is specified with a domain\username or UPN value, this parameter is ignored.

		.PARAMETER GetLog
			Indicates whether to try and retrieve any available log files from the server matching the change.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.PARAMETER PassThru
			If specified, will return the log object and not just display data.

        .EXAMPLE
			Get-ADObjectPropertyChangeInfo -Identity "john.smith" -Property "UserAccountControl"

			Gets information about when and where the UAC property was changed for john.smith.
        
        .EXAMPLE
            Get-ADObjectPropertyChangeInfo -Identity "john.smith" -Property "displayName" -GetLog

			Gets infomration about when and where the displayName property was changed for john.smith and also attempts to retrieve the log entry associated with this change.  

		.INPUTS
			None

		.OUTPUTS
			System.Diagnostics.Eventing.Reader.EventLogRecord[]

				This is returned when GetLog is specified on Windows 7/Server 2008 R2 and above.

			System.Diagnostics.EventLogEntry[] 

				This is returned when GetLog is specified and the OS is Windows Vista and below.	

			System.Management.Automation.PSObject

				This is returned when GetLog is not specified, it contains the originating time, originating server the change was logged on, and the value of the changed property.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/5/2017
	#>

	[CmdletBinding()]
	[OutputType([System.Diagnostics.Eventing.Reader.EventLogRecord[]], [System.Diagnostics.EventLogEntry[]], [System.Management.Automation.PSObject])]
	Param (
		[Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Identity,

		[Parameter(Position = 1, Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Property,

		[Parameter(Position = 2)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[Switch]$GetLog,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[Switch]$PassThru
	)

	Begin {
	}

	Process
	{
		$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat["Credential"] = $Credential
		}

		$Result = ConvertTo-ADObject -Identity $Identity -Domain $Domain @CredSplat

		$DC = Get-ADDomainController -DomainName $Result.Domain.DNSRoot -Discover

		if ($Result.Identity -ne $null)
		{
            $Results = @()
			
			[Microsoft.ActiveDirectory.Management.ADReplicationAttributeMetadata[]]$Data = Get-ADReplicationAttributeMetadata -Object $Result.Identity.DistinguishedName -ShowAllLinkedValues -Server "$($DC.Name).$($DC.Domain)" -Properties $Property @CredSplat

			if ($Data -ne $null -and $Data.Count -ge 1)
			{
                foreach ($Entry in $Data)
                {
				    [System.DateTime]$OriginatingTime = $Entry.LastOriginatingChangeTime

					if (![System.String]::IsNullOrEmpty($Entry.LastOriginatingChangeDirectoryServerIdentity))
					{
					    #The property looks like
						#CN=NTDS Settings,CN=SERVERNAME,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com

						$CN = $Entry.LastOriginatingChangeDirectoryServerIdentity.Trim("CN=NTDS Settings,CN=")
						$Name = $CN.Substring(0, $CN.IndexOf(","))

						try 
						{
							$OriginatingServer = Get-ADComputer -Identity $Name -Server $Result.Domain.DNSRoot @CredSplat | Select-Object -ExpandProperty DNSHostName
						}
						catch [Exception]
						{
						    $OriginatingServer = $Entry.Server
						}
					}
					else
					{
					    [System.String]$OriginatingServer = $Entry.Server
					}
                        
                    $Results += [PSObject]@{"OriginatingServer" = $OriginatingServer; "OriginatingTime" = $OriginatingTime; "Value" = $Entry.AttributeValue}
                }
		    }
			else
			{
			    Write-Warning -Message "No replication data found for property $Property."
			}
			
			if ($Results.Count -gt 0)
			{
                if ($GetLog)
				{
                    Write-Verbose -Message "Consider running this as a job, for example: `$Job = Start-Job -ScriptBlock {Get-UserObjectChangedLog -Identity `$args[0] -Property `$args[1] -GetLog} -ArgumentList @(`"$Identity`",`"$Property`")}" -ForegroundColor Yellow

                    foreach ($Item in $Results)
                    {
                        $OriginatingServer = $Item.OriginatingServer
                        $OriginatingTime = $Item.OriginatingTime
                        $Value = $Item.Value

						if (-not $PassThru)
						{
							Write-Host -Object ""
							Write-Host -Object "Originating Server:  $OriginatingServer"
							Write-Host -Object "Originating Time:    $OriginatingTime"
							Write-Host -Object "Value:               $Value"
							Write-Host -Object ""
						}

                        if (Test-Connection -ComputerName $Item.OriginatingServer -Count 1)
					    {
						    Write-Verbose -Object "Checking logs on $OriginatingServer for log associated with $Value, this could take awhile..."						   

						    #Event Id 4738 - A User Account Was Changed                          
                            #Event Id 5136 - A directory service object was modified
                            #Event Id 4742 - A computer account was changed

                            #Event Id 4737 - A security-enabled global group was changed.
                            #Event Id 4755 - A security-enabled universal group was changed
                            #Event Id 4735 - A security-enabled local group was changed

                            $EventIds = @()

                            switch ($Result.Identity.ObjectClass)
                            {
                                "group" {
                                    $EventIds += 4737
                                    $EventIds += 4755
                                    $EventIds += 4735
                                    break
                                }
                                "user" {
                                    $EventIds += 4738
                                    break
                                }
                                "computer" {
                                    $EventIds += 4742
                                    break
                                }
                                "organizationalUnit" {
                                    $EventIds += 5136
                                    break
                                }
                                "container" {
                                    $EventIds += 5136
                                    break
                                }
                            }

						    [System.Version]$Version = [System.Environment]::OSVersion.Version
						    [System.Decimal]$Version = [System.Decimal]::Parse("$($Version.Major).$($Version.Minor)")
                            
                            $Log = $null

						    if ($Version -ge 6.1)
						    {
                                #Specify EndTime because they start with the most recent log and work backwards
								[System.Diagnostics.Eventing.Reader.EventLogRecord[]]$Log = Get-WinEvent -ComputerName $OriginatingServer -MaxEvents 1 -FilterHashtable @{LogName=@("Security");ID=$EventIds;EndTime=$OriginatingTime} -ErrorAction SilentlyContinue @CredSplat | Where-Object {$_.Message -like "*$($Result.Identity.Name)*"}
						    }
						    else
						    {
								#Doesn't support credential parameter
								[System.Diagnostics.EventLogEntry[]]$Log = Get-EventLog -LogName "Security" -ComputerName $OriginatingServer -Before $OriginatingTime.AddSeconds(1) -After $OriginatingTime.AddSeconds(-1) -ErrorAction SilentlyContinue -Cre | Where-Object {$_.EventID -in $EventIds -and $_.TimeGenerated -eq $OriginatingTime -and $_.Message -like "*$($Result.Identity.Name)*"} | Sort-Object -Descending -Property TimeGenerated
						    }

						    if ($Log -ne $null -and $Log.Count -ge 1)
						    {
							    if ($PassThru)
							    {
								    Write-Output -InputObject $Log[0]	
							    }
                                else
                                {
                                    Write-Host -Object ($Log[0] | Format-List | Out-String)
                                }
						    }
						    else
						    {
							    Write-Warning -Message "No log files could be retrieved."
						    }
					    }
					    else
					    {
						    Write-Warning -Message "Could not contact $OriginatingServer to retrieve logs."
					    }
				    }
                }
			    else
				{
				    if ($PassThru)
					{
					    Write-Output -InputObject $Results
					}
                    else
                    {
                        foreach ($Item in $Results)
                        {
                            Write-Host -Object ""
				            Write-Host -Object "Originating Server:  $($Item.OriginatingServer)"
				            Write-Host -Object "Originating Time:    $($Item.OriginatingTime)"
                            Write-Host -Object "Value:               $($Item.Value)"
                            Write-Host -Object ""
                        }
                    }
				}               
			}
        }
		else
		{
			Write-Error -Message "Could not retrieve the specified principal, $Identity, from Active Directory."
		}
	}

	End {
	}
}

Function Get-ADGroupMembershipAddInfo {
	<#
		.SYNOPSIS
			Uses replication metadata to find when a member was added to a group.

		.DESCRIPTION
			The cmdlet gathers the replication metadata to find when a member was added to a group. This data can be used to search the logs on the identified Domain Controller to find who added the member.

		.PARAMETER GroupMember
			The Identity of the group member that was added. This can be the SAM Account Name, Display Name, Name, or CN.

		.PARAMETER Group
			The Identity of the group. This can be the SAM Account Name, Display Name, Name, or CN.

		.PARAMETER MemberDomain
            Optionally indicates the domain the group member exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the GroupMember parameter. 

		.PARAMETER GroupDomain
			Optionally indicates the domain the group exists in. If this parameter is not specified, the domain of the group member is used.

		.PARAMETER GetLog
			Indicates whether to try and retrieve any available log files from the server matching the change. Defaults to true.

		.PARAMETER UseActiveDirectoryPowershell
			Uses the Active Directory Powershell module to retrieve replication metadata. The default selection.

		.PARAMETER UseRepAdmin
			Uses the repadmin command line function and parses the output.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .PARAMETER PassThru
			If specified, will return the log object and not just display data.

        .EXAMPLE
			Get-ADGroupMembershipAddInfo -GroupMember Administrator -Group "Account Operators" -GetLog

			Writes out the server and time the member was added and attempts to retrieve the log file from the specified server for additional information which is written out to the pipeline.

		.INPUTS
			None

		.OUTPUTS
			System.Management.Automation.PSObject

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/5/2017
	#>
	[CmdletBinding(DefaultParameterSetName="Powershell")]
	[OutputType([System.Management.Automation.PSObject])]
	Param (
		[Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$GroupMember,

		[Parameter(Position = 1, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Group,

		[Parameter(Position = 2)]
		[ValidateNotNullOrEmpty()]
		[System.String]$MemberDomain = [System.String]::Empty,

		[Parameter(Position = 3)]
		[ValidateNotNullOrEmpty()]
		[System.String]$GroupDomain = [System.String]::Empty,

		[Parameter()]
		[Switch]$GetLog,

		[Parameter(ParameterSetName="Powershell")]
		[Switch]$UseActiveDirectoryPowershell,

		[Parameter(ParameterSetName="RepAdmin")]
		[Switch]$UseRepAdmin,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

        [Parameter()]
		[Switch]$PassThru
	)

	Begin {
	}

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$ADGroupMemberResult = ConvertTo-ADObject -Identity $GroupMember -Domain $MemberDomain @CredSplat

		if ([System.String]::IsNullOrEmpty($GroupDomain))
		{
			$GroupDomain = $ADGroupMemberResult.Domain.DNSRoot
		}

		[Microsoft.ActiveDirectory.Management.ADGroup]$ADGroup = Get-ADGroup -Identity $Group -Server $GroupDomain @CredSplat


		if ($ADGroup -ne $null)
		{
			Write-Verbose -Message "Found AD group $($ADGroup.Name)"

			$DC = Get-ADDomainController -DomainName $GroupDomain -Discover

			Write-Verbose -Message "Using $($DC.Name).$($DC.Domain) as the initial domain controller."

			if ($ADGroupMemberResult.Identity -ne $null)
			{
				Write-Verbose -Message "Found group member $($ADGroupMemberResult.Identity.DistinguishedName)"

				switch ($PSCmdlet.ParameterSetName)
				{	
					"RepAdmin"
					{
						$Data = repadmin /showmeta $ADGroup.Name $ADGroupMemberResult.Domain.DNSRoot

						#List only returns the first match
						#Context specifies the number of lines before and after that are returned around the matching line
						[System.String]$Line = $Data | Select-String -Pattern $ADGroupMember.Identity.Name -List -Context 2,0 
						$Content = $Line.Split(" ", [System.StringSplitOptions]::RemoveEmptyEntries)
						[System.String]$OriginatingServer = $Content[4].Substring($Content[4].IndexOf("\") + 1).Trim()
						[System.DateTime]$OriginatingTime = Get-Date($Content[2] + " " + $Content[3])

						break
					}
					"Powershell"
					{
						[Microsoft.ActiveDirectory.Management.ADReplicationAttributeMetadata]$Data = `
							Get-ADReplicationAttributeMetadata -Object $ADGroup.DistinguishedName -ShowAllLinkedValues -Server "$($DC.Name).$($DC.Domain)" -Properties member @CredSplat | `
							Where-Object {$_.AttributeValue -eq $ADGroupMemberResult.Identity.DistinguishedName} | `
							Sort-Object -Descending -Property "LastOriginatingChangeTime" | `
							Select-Object -First 1 

						if ($Data -ne $null)
						{
							[System.DateTime]$OriginatingTime = $Data.LastOriginatingChangeTime

							if (![System.String]::IsNullOrEmpty($Data.LastOriginatingChangeDirectoryServerIdentity))
							{
								$CN = $Data.LastOriginatingChangeDirectoryServerIdentity.Trim("CN=NTDS Settings,CN=")
								$Name = $CN.Substring(0, $CN.IndexOf(","))

								try 
								{
									[System.String]$OriginatingServer = Get-ADComputer -Identity $Name -ErrorAction Stop @CredSplat | Select-Object -ExpandProperty DNSHostName
								}
								catch [Exception]
								{
									[System.String]$OriginatingServer = $Data.Server
								}
							}
							else
							{
								[System.String]$OriginatingServer = $Data.Server
							}
						}

						break
					}
					default
					{
						throw "Could not determine parameter set."
					}
				}

				if ($Data -ne $null)
				{
					if (-not $PassThru)
					{
						Write-Host -Object "Originating Server:  $OriginatingServer"
						Write-Host -Object "Originating Time:    $OriginatingTime"
					}

					if ($GetLog)
					{
						if (Test-Connection -ComputerName $OriginatingServer -Count 1 @CredSplat)
						{
							Write-Verbose -Object "Checking logs on $OriginatingServer, this could take awhile..."
							Write-Verbose -Object "Consider running this as a job: `$Job = Start-Job -ScriptBlock {Get-WhenMemberAddedToGroup -Group `$args[0] -GroupMember `$args[1]} -ArgumentList `"$Group`",`"$GroupMember`"" -ForegroundColor Yellow

							# Event Id 4732, 636 - Member added to a domain local group
							# Event Id 4728, 632 - Member added to a global group
							# Event Id 4756, 660 - Member added to a universal group

                            $EventIds = @(4732,4728,4756,636,632,660)

							$Version = [System.Environment]::OSVersion.Version
							[System.Decimal]$Version = [System.Decimal]::Parse("$($Version.Major).$($Version.Minor)")
                            
                            $Log = $null

							if ($Version -ge 6.1)
							{                     
								[System.Diagnostics.Eventing.Reader.EventLogRecord[]]$Log = Get-WinEvent -ComputerName $OriginatingServer -MaxEvents 1 -FilterHashtable @{LogName=@("Security");ID=$EventIds;StartTime=$OriginatingTime} -ErrorAction SilentlyContinue @CredSplat | Where-Object {$_.Message -like "*$($ADGroupMemberResult.Identity.Name)*"} 
							}
							else
							{
								[System.Diagnostics.EventLogEntry[]]$Log = Get-EventLog -LogName "Security" -ComputerName $OriginatingServer -Before $OriginatingTime.AddSeconds(1) -After $OriginatingTime.AddSeconds(-1) -ErrorAction SilentlyContinue | Where-Object {$_.EventID -in $EventIds -and $_.TimeGenerated -eq $OriginatingTime -and $_.Message -like "*$ADGroupMember*"}
							}

							if ($Log -ne $null -and $Log.Count -ge 1)
							{
								if ($PassThru)
								{
									Write-Output -InputObject $Log[0]	
								}
                                else
                                {
                                    Write-Host -Object ($Log[0] | Format-List | Out-String)
                                }
							}
							else
							{
								Write-Warning -Message "No log files could be retrieved."
							}
						}
						else
						{
							Write-Warning -Message "Could not contact $OriginatingServer to retrieve logs."
						}
					}
					else
					{
						if ($PassThru) 
                        {
							Write-Output -InputObject (New-Object PSObject -Property @{"Originating Server"=$OriginatingServer;"Originating Time"=$OriginatingTime})
						}
					}
				}
                else
                {
                    Write-Warning -Message "No replication data found for Object $($ADGroup.Name) and Property 'member'."
                }
			}
			else
			{
				Write-Error -Message "Could not find the specified group member: $GroupMember"
			}
		}
		else
		{
			Write-Error -Message "Could not find the specified group: $Group"
		}
	}

	End	{		
	}
}

Function Get-ADPrincipalDetails {
	<#
		.SYNOPSIS
			Gets details about a specific AD principal.

		.DESCRIPTION
			Gets information about an AD principal to include the principals DistinguishedName, whether it has Domain or Enterprise admin rights, and its complete group membership.

            This cmdlet is used by the Test-IsDomainAdmin, Test-IsEnterpriseAdmin, and Test-IsEnterpriseOrDomainAdmin, but could be useful for other purposes.

            Domain controllers are reported as having Domain Admin privileges.

		.EXAMPLE
			Get-ADPrincipalDetails -Identity "Domain Admins" -Domain contoso

            Gets information about the Domain Admin group

		.PARAMETER Identity
            The identity of the AD principal to gather details on. This is a string that is matched against AD object properties:

                -Name
                -SamAccountName
                -CN
                -DistinguishedName
                -Display Name
                -ObjectSID
                -ObjectGUID

            For user objects, the identity can be provided as a User Principal Name (UPN) or domain\username format. In these cases, the domain will be extracted
            from the identity and does not need to be specified. 

            If this parameter is not specified, the current windows identity principal is utilized, which could be a user or system account, which is translated to the corresponding
            computer object.

		.PARAMETER Domain
            Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter. If the identity parameter is specified, the current user domain is used. If the identity parameter is not specified, and the current windows identity is
            the system account, the local computer domain is used, otherwise the current user domain is used.

            If the Identity parameter is specified with a domain\username or UPN value, this parameter is ignored.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.INPUTS
			System.String

		.OUTPUTS
			System.Management.Automation.PSCustomObject

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>
	[CmdletBinding()]
	[OutputType([System.Management.Automation.PSCustomObject])]
	Param(
		[Parameter(Position = 0, ValueFromPipeLine = $true, Mandatory= $true)]
		[AllowEmptyString()]
		[System.String]$Identity = [System.String]::Empty,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		[System.Boolean]$DomainAdmin = $false
		[System.Boolean]$EnterpriseAdmin = $false

        $Result = ConvertTo-ADObject -Identity $Identity -Domain $Domain @CredSplat

        if ($Result.Identity -ne $null)
        {
            #If the computer is a domain controller, it has domain admin rights under the SYSTEM account
            if ($Result.Identity.ObjectClass -eq "computer")
            {
                $DNs = Get-ADDomainController -Filter * @CredSplat | Select-Object -ExpandProperty ComputerObjectDN

                if ($Result.Identity.DistinguishedName -in $DNs)
                {
                    $DomainAdmin = $true

					[Microsoft.ActiveDirectory.Management.ADForest]$Forest = Get-ADForest -Identity $Result.Forest.DNSRoot

					if ($Result.Domain.DNSRoot -eq $Forest.RootDomain)
					{
						#The DC is in the forest root domain, so it has enterprise admin rights
						$EnterpriseAdmin = $true
					}
                }
            }

			#Only do a group membership review if we haven't determined this was an enterprise DC
			if ($DomainAdmin -ne $true -or $EnterpriseAdmin -ne $true)
			{
				[Microsoft.ActiveDirectory.Management.ADGroup[]]$Groups = Get-ADPrincipalGroupMembership -Identity $Result.Identity.DistinguishedName -Domain $Result.Domain.DNSRoot @CredSplat

				if ($Result.Identity.ObjectClass -eq "group")
				{
					[Microsoft.ActiveDirectory.Management.ADGroup]$Group = Get-ADGroup -Identity $Result.Identity.DistinguishedName -Server $Result.Domain.DNSRoot @CredSplat
					$Groups += $Group
				}

				[Security.Principal.SecurityIdentifier]$DomainAdminSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::AccountDomainAdminsSid, $Result.Domain.DomainSID)      
				[Security.Principal.SecurityIdentifier]$EnterpriseAdminSID = New-Object -TypeName System.Security.Principal.SecurityIdentifier([System.Security.Principal.WellKnownSidType]::AccountEnterpriseAdminsSid, $Result.Forest.DomainSID )

				foreach ($Group in $Groups)
				{
					Write-Verbose -Message "Evaluating $($Group.DistinguishedName) for SID"
					if ($Group.SID -eq $EnterpriseAdminSID) 
					{
						$EnterpriseAdmin = $true
					}
					elseif ($Group.SID -eq $DomainAdminSID)
					{
						$DomainAdmin = $true
					}
				
					#Since both have been found, don't need to review the rest of the groups
					if ($DomainAdmin -eq $true -and $EnterpriseAdmin -eq $true)
					{
						break
					} 
				}
			}

		    Write-Output -InputObject ([PSCustomObject]@{Identity = $Result.Identity.DistinguishedName; EnterpriseAdmin = $EnterpriseAdmin; DomainAdmin = $DomainAdmin; Domain = $Result.Domain.DNSRoot; Forest = $Result.Forest.DNSRoot; Groups = $Groups})
        }
        else
        {
            throw [System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectExistsException]"Could not find $Identity"
        }
	}

	End {
	}
}

Function Get-ADPrincipalGroupMembership {
	<#
		.SYNOPSIS
			Gets the complete group membership of an AD principal. 

		.DESCRIPTION
			The Get-ADPrincipalGroupMembership gets all nested group membership of an AD principal. The principal can be a user, computer, or group.

        .EXAMPLE
			Get-ADPrincipalGroupMembership -Identity Administrator

	        Gets all group membership for the Administrator account.

		.EXAMPLE
			Get-ADPrincipalGroupMembership -Identity "Domain Admins -Domain root

	        Gets all group membership for the Domain Admins group in the root domain. This command could be run from a different domain that also
			had a group named "Domain Admins".

		.PARAMETER Identity
			The identity of the AD principal to get group membership for. This is a string that is matched against AD object properties:

                -Name
                -SamAccountName
                -CN
                -DistinguishedName
                -Display Name
                -ObjectSID
                -ObjectGUID

            For user objects, the identity can be provided as a User Principal Name (UPN) or domain\username format. In these cases, the domain will be extracted
            from the identity and does not need to be specified. 

            If this parameter is not specified, the current windows identity principal is utilized, which could be a user or system account, which is translated to the corresponding
            computer object.

		.PARAMETER Domain
			Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter. If the identity parameter is specified, the current user domain is used. If the identity parameter is not specified, and the current windows identity is
            the system account, the local computer domain is used, otherwise the current user domain is used.

            If the Identity parameter is specified with a domain\username or UPN value, this parameter is ignored.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.INPUTS
			System.String

		.OUTPUTS
			Microsoft.ActiveDirectory.Management.ADGroup[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>
	[CmdletBinding()]
	[OutputType([Microsoft.ActiveDirectory.Management.ADGroup[]])]
	Param(
		[Parameter(ValueFromPipeline = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Identity,

        [Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
        [System.String]$Domain,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Result = ConvertTo-ADObject -Identity $Identity -Domain $Domain @CredSplat
        
        #The groups array will contain the final set of groups
		$Groups = @()

        #The queue will hold the groups that need to be evaluated in the nested hierarchy
        [System.Collections.Queue]$GroupsToCheck = New-Object -TypeName System.Collections.Queue

        Write-Verbose -Message "Evaluating $($Result.Identity.DistinguishedName)"

        #Get the group membership of the evaluated principal
        #Use the memberOf property because Get-ADPrincipalGroupMembership doesn't accept all object classes like foreignSecurityPrincipal

		[Microsoft.ActiveDirectory.Management.ADGroup[]]$NewGroups = $Result.Identity.memberOf | ForEach-Object {
            $QueryDomain = $_.Substring($_.IndexOf("DC=")).Replace("DC=", "").Replace(",",".")

            Write-Output -InputObject (Get-ADGroup -Identity $_ -Server $QueryDomain @CredSplat)
        }

        #Add the immediate group membership to the groups to check and the discovered groups
        if ($NewGroups.Count -gt 0)
        {
		    foreach ($Group in $NewGroups)
		    {
                Write-Verbose -Message "`tMember Of: $Group"
                Write-Verbose -Message "`t`tAdding to groups"
			    $GroupsToCheck.Enqueue($Group)
                $Groups += $Group
		    }
        }
        else
        {
            Write-Verbose -Message "`tNo parent groups."
        }

        #While there are groups to check, get the group membership of each group
		while ($GroupsToCheck.Count -gt 0)
		{
            [Microsoft.ActiveDirectory.Management.ADGroup]$Group = $GroupsToCheck.Dequeue()
            Write-Verbose -Message "Evaluating $Group"

            $QueryDomain = $Group.DistinguishedName.Substring($Group.DistinguishedName.IndexOf("DC=")).Replace("DC=", "").Replace(",",".")

			[Microsoft.ActiveDirectory.Management.ADGroup[]]$NewGroups = Get-ADPrincipalGroupMembership -Identity $Group -Domain $QueryDomain -ErrorAction SilentlyContinue @CredSplat

            #If the groups array doesn't have the group yet, add it
            #There may be group memberships where two groups are both members of the same parent group, or there may be
            #circular nesting where A is a member of B, B is a member of C, and C is a member of A
			if ($NewGroups.Count -gt 0)
            {
                foreach ($Group in $NewGroups)
			    {
                    Write-Verbose -Message "`tMember Of: $Group"
				    if (($Groups | Select-Object -ExpandProperty DistinguishedName) -notcontains $Group.DistinguishedName)
				    {
                        Write-Verbose -Message "`t`tAdding to groups."
					    $GroupsToCheck.Enqueue($Group)
					    $Groups += $Group
				    }
                    else
                    {
                        Write-Verbose -Message "`t`tAlready discovered."
                    }
			    }
            }
            else
            {
                Write-Verbose -Message "`tNo parent groups."
            }
		}

		#Return the updated total group membership
		Write-Output -InputObject $Groups
	}

	End {
	}
}

Function Get-ADGroupMembers {
<#
		.SYNOPSIS
			Gets the complete group membership of an AD group. 

		.DESCRIPTION
			The Get-ADNestedGroupMembers gets all nested group members of an AD group.

		.PARAMETER Identity
			The identity of the AD group to get group members of. This is a string that is matched against AD object properties:

                -Name
                -SamAccountName
                -CN
                -DistinguishedName
                -Display Name
                -ObjectSID
                -ObjectGUID


		.PARAMETER Domain
			Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Get-ADGroupMembers -Identity Administrators

	        Gets all group members in the Administrators group.

		.EXAMPLE
			Get-ADGroupMembers -Identity "Domain Admins" -Domain root

	        Gets all group members for the Domain Admins group in the root domain. This command could be run from a different domain that also
			had a group named "Domain Admins".

		.INPUTS
			System.String

		.OUTPUTS
			Microsoft.ActiveDirectory.Management.ADObject[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>
	[CmdletBinding()]
	[OutputType([Microsoft.ActiveDirectory.Management.ADObject[]])]
	Param(
		[Parameter(ValueFromPipeline = $true, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Identity,

        [Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
        [System.String]$Domain,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Result = ConvertTo-ADObject -Identity $Identity -Domain $Domain @CredSplat

        if ($Result.Identity.ObjectClass -ieq "group")
        {
            # This will hold all of the groups we need to evaluate the membership of to find nested members
            [Microsoft.ActiveDirectory.Management.ADObject[]]$Groups = @()
            [System.String[]]$GroupsStr = @()

            # This is the top level group we are evaluating
            [Microsoft.ActiveDirectory.Management.ADGroup]$Group = Get-ADGroup -Identity $Result.Identity.DistinguishedName -Properties Members @CredSplat

            # These are the direct level members of the group
            [Microsoft.ActiveDirectory.Management.ADObject[]]$Members = $Group.Members | Get-ADObject @CredSplat
            $GroupsStr += $Members | Select-Object -ExpandProperty DistinguishedName

            # Keep track of just the DNs of the discovered members to make it easy to see if we've added a user or group to the total members list already
            [System.String[]]$MemberDNs = $Members | Select-Object -ExpandProperty DistinguishedName

            # Populate the groups array with first level members of the group that are also groups
            $Groups += $Members | Where-Object {$_.ObjectClass -ieq "group"}

            while ($Groups.Length -gt 0)
            {
                # This will hold newly found groups in the child groups being evaluated in the foreach loop
                [Microsoft.ActiveDirectory.Management.ADObject[]]$NewGroups = @()
                
                foreach ($Grp in $Groups)
                {
                    # Get the group so we can get the members property, we can't get this on an ADObject
                    [Microsoft.ActiveDirectory.Management.ADGroup]$MemberGroup = Get-ADGroup -Identity $Grp.DistinguishedName -Properties Members @CredSplat
                    
                    # Retrieve the direct members of this group
                    [Microsoft.ActiveDirectory.Management.ADObject[]]$NewMembers = $MemberGroup.Members | Get-ADObject @CredSplat

                    # Add newly found groups to the new groups list if they aren't members yet (otherwise we've already evaluated their members)
                    $NewGroups += $NewMembers | Where-Object {$_.ObjectClass -ieq "group" -and $MemberDNs -inotcontains $_.DistinguishedName}

                    # Add the current group we're evaluating to the new members list so we can include it in the iteration below
                    $NewMembers += (Get-ADObject -Identity $MemberGroup.DistinguishedName @CredSplat)

                    # Check each newly discovered member to see if they have already been added to the total membership list (they might have
                    # from being a member in another group that was also a child of the parent)
                    foreach ($NewMember in $NewMembers)
                    {
                        if ($MemberDNs -inotcontains $NewMember.DistinguishedName)
                        {
                            Write-Verbose -Message "Adding $($NewMember.DistinguishedName) to membership."
                            $Members += $NewMember
                        }
                    }

                    # Update the member DNs here so that in case two groups in the foreach loop both contain the same members, they won't
                    # get added twice
                    $MemberDNs = $Members | Select-Object -ExpandProperty DistinguishedName
                }

                # Update the groups array with any newly found groups
                $Groups = $NewGroups
                
            }

            Write-Output -InputObject $Members
        }
        else
        {
            throw "Provided identity must be a security or distribution group."
        }
    }

    End {
    }
}

Function Get-OldADUsers {
	<#
		.SYNOPSIS
			Get users that haven't logged in for the specified time.

		.DESCRIPTION
			The cmdlet finds all users that haven't logged in for the specified time. It first looks for the msDS-LastSuccessfulInteractiveLogon if that has been enabled in the domain. If it is not present, it uses the LastLogonTimeStamp.

		.PARAMETER OlderThan
			The number of days since the last logon.

		.PARAMETER SearchBase
			The DistinguishedName of the OU path to search under. This defaults to the root of the domain.

		.PARAMETER Domain
			The domain to search in.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

        .EXAMPLE
			Get-OldUsers -DaysOld 60
			
			Gets all users that haven't logged on in at least 60 days.

		.EXAMPLE 
			Get-OldUsers -DaysOld 60 -SearchBase "OU=Finance,OU=HQ,DC=contoso,DC=com"

			Gets all users in the Finance OU and child OUs that haven't logged on in at least 60 days.

		.INPUTS
			System.Int32

		.OUTPUTS
			System.Management.Automation.PSObject[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 1/7/2017
	#>

	[CmdletBinding()]
	[OutputType([System.Management.Automation.PSObject[]])]
	Param(
		[Parameter(Position = 0, Mandatory = $true, ValueFromPipeLine = $true)]
		[System.Int32]$DaysOld,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$SearchBase = [System.String]::Empty,

		[Parameter(Position = 2)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process
	{
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Result = @()

		if ([System.String]::IsNullOrEmpty($Domain))
		{
			$Domain = $env:USERDOMAIN
		}
		
		[Microsoft.ActiveDirectory.Management.ADDomain]$ADDomain = Get-ADDomain -Identity $Domain @CredSplat

		if ($SearchBase -eq [System.String]::Empty)
		{
			$SearchBase = $ADDomain.DistinguishedName
		}

		$Users = Get-ADUser -Filter * -Property UserAccountControl,"msDS-LastSuccessfulInteractiveLogonTime",LastLogonTimeStamp,LastLogon -SearchBase $SearchBase -Server $ADDomain.DNSRoot @CredSplat |
			Select-Object -Property DistinguishedName,Enabled,LastLogon,LastLogonTimeStamp,"msDS-LastSuccessfulInteractiveLogonTime",UserAccountControl,SamAccountName

		foreach ($User in $Users)
		{
			Write-Verbose -Message "Reviewing user $($User.DistinguishedName)"
			$UserObject = New-Object -TypeName PSObject -Property @{"Days Since Last Logon"= 0; UserName = $User.DistinguishedName; "Last Logon" = $null; UAC = $User.UserAccountControl}

			if ($User."msDS-LastSuccessfulInteractiveLogonTime" -ne $null -and $User."msDS-LastSuccessfulInteractiveLogonTime" -ne [System.String]::Empty -and 
				$User."msDS-LastSuccessfulInteractiveLogonTime" -ne 0)
			{
				Write-Verbose -Message "Last interactive logon $($User."msDS-LastSuccessfulInteractiveLogonTime")"
				$UserObject."Last Logon" = (Get-Date -Date $User."msDS-LastSuccessfulInteractiveLogonTime").AddYears(1600) 
			}
			elseif ($User.LastLogonTimeStamp -ne $null -and $User.LastLogonTimeStamp -ne 0)
			{
				Write-Verbose -Message "Last logon timestamp $($User.LastLogonTimeStamp)"
				$UserObject."Last Logon" = (Get-Date -Date $User.LastLogonTimeStamp).AddYears(1600)
			}
			elseif ($User.LastLogon -ne $null -and $User.LastLogon -ne 0)
			{
				Write-Verbose -Message "Last logon $($User.LastLogon)"
				$UserObject."Last Logon" = (Get-Date -Date $User.LastLogon).AddYears(1600)
			}
			else 
			{
				Write-Verbose -Message "User object has no logon information"
				$UserObject."Last Logon" = [System.DateTime]::MinValue
			}

			Write-Verbose -Message "Last logon $($UserObject."Last Logon")"

			$UserObject."Days Since Last Logon" = ((Get-Date).ToUniversalTime() - [System.DateTime]($UserObject."Last Logon")).TotalDays

			Write-Verbose -Message "Days since last logon $($UserObject."Days Since Last Logon")"

			if ($UserObject."Days Since Last Logon" -ge $DaysOld)
			{
				$Result += $UserObject
			}

			Write-Verbose -Message "----------"
		}

		Write-Output -InputObject $Result
	}

	End {
	}
}

Function Get-ADUserAccountControl {
	<#
		.SYNOPSIS
			Gets an enumeration of a user's UserAccountControl attribute.

		.DESCRIPTION
			The Get-ADUserAccountControl cmdlet gets the value from a user's UserAccountControl attribute and enumerates it to the different parts that create the bitwise value.

        .EXAMPLE
			Get-ADUserAccountControl -Identity "John Smith"

	        Gets the UAC enumeration for John Smith.

		.PARAMETER Identity
			The identity of the object, can be a SamAccountName, DistinguishedName, Name, Display Name, CN, ObjectSID, ObjectGUID or DisplayName property.

		.PARAMETER Domain
            Optionally indicates the domain the object exists in. If this parameter is not specified, the domain of the local user or computer is used, depending on what is specified for
            the Identity parameter. If the identity parameter is specified, the current user domain is used. If the identity parameter is not specified, and the current windows identity is
            the system account, the local computer domain is used, otherwise the current user domain is used.

            If the Identity parameter is specified with a domain\username or UPN value, this parameter is ignored.

		.PARAMETER Credential
			Specifies a user account that has permission to perform this action. The default is the current user.

			Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a user name, you will be prompted for a password.

		.INPUTS
			System.String

		.OUTPUTS
			System.Management.Automation.PSCustomObject[]

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/30/2017
	#>

	[CmdletBinding()]
	[OutputType([System.Management.Automation.PSCustomObject[]])]
	Param (
		[Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Identity,

		[Parameter(Position = 1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {		
	}

	Process {
		[System.Collections.Hashtable]$CredSplat = @{}

		if ($Credential -ne [PSCredential]::Empty)
		{
			$CredSplat.Add("Credential", $Credential)
		}

		$Result = ConvertTo-ADObject -Identity $Identity -Domain $Domain @CredSplat

		if ($Result.Identity -ne $null)
		{
			if ($Result.Identity.ObjectClass -in @("user", "computer"))
			{
				$UAC = $Result.Identity.UserAccountControl

				$Matches = @()
				foreach ($Value in $script:UACValues) {
					#Perform bitwise 'and' to compare the current UAC against each possible value and record matches
					if ($UAC -band [System.Convert]::ToInt64($Value.Key, 16)) {
						$Matches += $Value
					}
				}

				Write-Output -InputObject $Matches
			}
			else
			{
				Write-Error -Message "The identity must be either a user or computer object."
			}
		}
		else
		{
			Write-Error -Message "Could not find $Identity"
		}
	}

	End {		
	}
}

Function Get-ADComputerSite {
	<#
		.SYNOPSIS
			Gets the AD Site for the specified computer.

		.DESCRIPTION
			Calls DsGetSiteName() and retrieves the current Active Directory site for the specified ComputerName. The cmdlet will throw an exception if it cannot
			contact the specified computer or if the computer is not part of a site.

		.PARAMETER ComputerName
			The computer to query the AD site name for. Leave this blank to query the local machine.

		.PARAMETER AsADSite
			This parameter specifies that the site name returned to DsGetSiteName is supplied to Get-ADReplicationSite and returns a Microsoft.ActiveDirectory.Management.ADReplicationSite instead of a string.

		.EXAMPLE
			$SiteName = Get-ADComputerSite

			Gets the AD site for the local computer. The return value would be Default-First-Site-Name if the computer is in that AD site.

		.EXAMPLE
			$SiteName = Get-ADComputerSite -ComputerName myserver01

			Gets the AD site for the remote computer myserver01.

		.EXAMPLE
			[Microsoft.ActiveDirectory.Management.ADReplicationSite]$ReplSite = Get-ADComputerSite -AsADSite

			Gets the AD site the local computer is a member of as an Microsoft.ActiveDirectory.Management.ADReplicationSite object.

		.INPUTS
			System.String

		.OUTPUTS
			System.String, Microsoft.ActiveDirectory.Management.ADReplicationSite

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 8/7/2017
	#>
	[CmdletBinding()]
	[OutputType([System.String])]
	Param(
		[Parameter()]
		[ValidateNotNull()]
		[System.String]$ComputerName = [System.String]::Empty,

		[Parameter()]
		[Switch]$AsADSite
	)

	Begin {
		Add-Type -TypeDefinition $script:AdSite
	}

	Process {
		[System.String]$SiteName = [NetApi32]::DsGetSiteName($ComputerName)

		if ($AsADSite)
		{
			Write-Output -InputObject (Get-ADReplicationSite -Identity $SiteName)
		}
		else {
			Write-Output -InputObject $SiteName
		}
	}

	End {
	}
}

Function Rename-ADSite {
	<#
		.SYNOPSIS
			Renames the specified Active Directory Site.

		.DESCRIPTION
			Renames the specified Active Directory Site

		.PARAMETER Name
			The current identity of the Active Directory site, this defaults to "Default-First-Site-Name".

		.PARAMETER NewName
			The new name of the Active Directory site.

		.PARAMETER Server
			The domain controller to target for the operation. If this is not specified, the current domain of the local computer will
			be used to find a domain controller.

		.INPUTS
			None
		
		.OUTPUTS
			Microsoft.ActiveDirectory.Management.ADReplicationSite

		.EXAMPLE
			Rename-ADSite -NewName "Headquarters"

			Renames the Default-First-Site-Name site to Headquarters.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding()]
	[OutputType([Microsoft.ActiveDirectory.Management.ADReplicationSite])]
    Param (
		[Parameter(Position=1)]
		[ValidateNotNullOrEmpty()]
		[System.String]$Name = "Default-First-Site-Name",

        [Parameter(Position=0, Mandatory=$true)]
		[ValidateNotNullOrEmpty()]
		[ValidateScript({
			$_ -ine $Name
		})]
        [System.String]$NewName,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server = [System.String]::Empty

    )

    Begin {
	}

    Process {
		if ([System.String]::IsNullOrEmpty($Server))
		{
			$Server = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain
		}

		$Splat = @{}
		$Splat.Add("Server", $Server)

        $Site = Get-ADReplicationSite -Identity $Name @Splat | Rename-ADObject -NewName $NewName -PassThru @Splat
		Write-Output -InputObject $Site
    }

    End {    
    }
}

Function Add-ADSiteSubnet {
	<#
		.SYNOPSIS
			Adds a single subnet to an Active Directory site.

		.DESCRIPTION
			Adds a single subnet to an Active Directory site. If the subnet already exists as a replication subnet, it is assigned to the specified Site, which will remove it from any pre-existing association. If it does not exist, it is added and assigned to the site.

		.PARAMETER SiteSubnet
			The subnet to add to the site, should be in the form of X.X.X.X/CIDR.

		.PARAMETER SiteName
			The site the subnet will be added to. This defaults to the current site of the computer the cmdlet is being run on.

		.PARAMETER Server
			The domain controller to target for the operation. If this is not specified, the current domain of the local computer will
			be used to find a domain controller.

		.INPUTS
			None
		
		.OUTPUTS
			Microsoft.ActiveDirectory.Management.ADReplicationSubnet

		.EXAMPLE 
			Add-ADSiteSubnet -SiteSubnet "192.168.1.0/24" -SiteName "Headquarters"

			The 192.168.1.0/24 subnet is added to the Headquarters site.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding()]
	[OutputType([Microsoft.ActiveDirectory.Management.ADReplicationSubnet])]
    Param(
        [Parameter(Mandatory=$true, Position=0)]
		[ValidateNotNullOrEmpty()]
        [System.String]$SiteSubnet,

        [Parameter(Position=1)]
		[ValidateNotNullOrEmpty()]
        [System.String]$SiteName = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server = [System.String]::Empty
    )

    Begin {       
    }

    Process {
		if ([System.String]::IsNullOrEmpty($Server))
		{
			$Server = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain
		}

		$Splat = @{}
		$Splat.Add("Server", $Server)

		if ([System.String]::IsNullOrEmpty($SiteName)) 
		{
            $SiteName = Get-ADReplicationSite @Splat | Select-Object -First 1 -ExpandProperty Name
        }

		try 
		{
			$ExistingSubnet = Get-ADReplicationSubnet -Identity $SiteSubnet -ErrorAction SilentlyContinue @Splat

			if ($ExistingSubnet -eq $null) 
			{
				$Subnet = New-ADReplicationSubnet -Name $SiteSubnet -Site $SiteName @Splat
			}
			else 
			{
				$Subnet = Set-ADReplicationSubnet -Identity $ExistingSubnet -Site $SiteName -PassThru @Splat
			}
		}
		catch [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] 
		{
			$Subnet = New-ADReplicationSubnet -Name $SiteSubnet -Site $SiteName @Splat
		}

		Write-Output -InputObject $Subnet
    }

    End {      
    }
}

Function Get-ADSysvolLocalPath {
	<#
		.SYNOPSIS
			Gets the local path on a domain controller that hosts the SYSVOL.

		.DESCRIPTION
			This cmdlet connects to a remote domain controller and retrieves the local path the SYSVOL is hosted on.
		
			An exception will be thrown is the targetted server is not a domain controller.

		.PARAMETER Server
			The domain controller to retrieve the SYSVOL path from. If this is not specified, the cmdlet runs against the local machine.

		.PARAMETER Credential
			The credential to use to remotely connect to the domain controller.

		.PARAMETER Session
			An active PSSession to use for the remote connection.

		.EXAMPLE
			Get-ADSysvolLocalPath -Server dc1.contoso.com

			This retrieves the local directory path on dc1 that hosts the SYSVOL.

		.INPUT
			System.String

		.OUTPUT
			System.String

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/20/2017
	#>
	[CmdletBinding()]
	[OutputType([System.String])]
	Param(		
		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server,

        [Parameter()]
        [ValidateNotNull()]
        [System.Management.Automation.Credential()]
        [System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Runspaces.PSSession]$Session = $null
	)

	Begin {
	}

	Process {
		$Splat = @{}

		if ([System.String]::IsNullOrEmpty($Server))
		{
			$Server = $env:COMPUTERNAME
		}

		if ($Server.Split(".")[0] -ine $env:COMPUTERNAME)
		{
			$Splat.Add("ComputerName", $Server)
		}

		if ($Session -ne $null)
		{
			$Splat.Add("Session", $Session)
		}

		if ($Credential -ne [System.Management.Automation.PSCredential]::Empty)
		{
			$Splat.Add("Credential", $Credential)
		}

		$Path = Invoke-Command -ScriptBlock {
            $ProductType = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty ProductType
            
            if ($ProductType -eq 2)
            {
			    Write-Output -InputObject (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters" | Select-Object -ExpandProperty SysVol)
            }
            else 
            {
                throw "The specified server $env:COMPUTERNAME is not a domain controller."
            }
		} @Splat

		Write-Output -InputObject $Path
	}

	End {
	}
}

Function Enable-ADRecycleBin {
	<#
		.SYNOPSIS
			Enables the AD recycle bin.

		.DESCRIPTION
			Enables the AD recycle bin in the specified forest.

		.PARAMETER ForestRootDomainName
			The name of the forest root domain. This defaults to the forest of the computer the cmdlet is being run on.

		.PARAMETER Server
			The domain controller to target for the operation. If this is not specified, the current domain of the local computer will
			be used to find a domain controller.

		.INPUTS
			System.String
		
		.OUTPUTS
			None

		.EXAMPLE 
			Enable-ADRecycleBin -ForestRootDomainName "admin.local"

			Enables the AD recycle bin in the admin.local forest.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
    [CmdletBinding()]
	[OutputType()]
    Param(
        [Parameter(Position = 0, ValueFromPipeline = $true)]
		[ValidateNotNullOrEmpty()]
        [System.String]$ForestRootDomainName = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server = [System.String]::Empty
    )

    Begin {        
    }

    Process {
		if ([System.String]::IsNullOrEmpty($Server))
		{
			$Server = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain
		}

		$Splat = @{}
		$Splat.Add("Server", $Server)

		if ([System.String]::IsNullOrEmpty($ForestRootDomainName)) 
		{
            $ForestRootDomainName = Get-ADForest -Current LocalComputer @Splat | Select-Object -ExpandProperty Name
        }
		
		Write-Verbose -Message "Enabling recycle bin in $ForestRootDomainName."

        Enable-ADOptionalFeature -Identity "Recycle Bin Feature" -Scope ForestOrConfigurationSet -Target $ForestRootDomainName -Confirm:$false

		Write-Verbose -Message "AD Recycle Bin successfully enabled."
    }

    End {		
    }
}

Function Enable-ADCentralPolicyStore {
	<#
		.SYNOPSIS
			Creates the Central Policy Store for GPOs in the specified domain.

		.DESCRIPTION
			Creates the Central Policy Store in the SYSVOL. Then, the cmdlet extracts the ADMX and English ADML files in the specified zip, or uses the local ADMX and English ADML files in the PolicyDefinitions folder, and 
			moves those to the Central Policy Store.

			This cmdlet can be run directly on a domain controller or it can be executed remotely.

		.PARAMETER FilePath
			The path to the zip containing the ADMX and ADML files.

		.PARAMETER Domain
			The domain to create the Central Policy Store for. If this is not specified, it defaults to the current domain of the local computer. The domain name
			will be used to discover a domain controller.

		.PARAMETER Server
			The domain controller to run the setup on.

		.PARAMETER Credential
			Optionally specify a credential to use to connect to the domain controller.

		.INPUTS
			None
		
		.OUTPUTS
			None

		.EXAMPLE 
			Enable-ADCentralPolicyStore -Domain contoso.com

			Creates the Central Policy Store for the contoso.com domain. A domain controller in that domain is discovered. The user running the cmdlet
			needs administrative privileges on the found domain controller.

		.EXAMPLE
			Enable-ADCentralPolicyStore -Server dc1.tailspintoys.com -Credential (Get-Credential)

			In this example, the cmdlet is being run from a machine in the contoso.com domain. The target server is dc1.tailspintoys.com in the tailspintoys.com domain and
			sets up the Central Policy Store for the tailspintoys.com domain. Credentials that provide administrative access to dc1 are prompted for when the cmdlet is executed.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding(DefaultParameterSetName = "Domain")]
	[OutputType()]
    Param (
		[Parameter(Position=0)]
		[ValidateNotNullOrEmpty()]
        [ValidateScript({
            Test-Path -Path $_
        })]
		[System.String]$FilePath = [System.String]::Empty,

		[Parameter(ParameterSetName = "Domain")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Domain = [System.String]::Empty,

		[Parameter(ParameterSetName = "Server")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server,

        [Parameter()]
        [ValidateNotNull()]
        [System.Management.Automation.Credential()]
        [System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
    )

    Begin {       
    }

    Process {
        $CredSplat = @{}
		$Splat = @{}

        if ($Credential -ne [System.Management.Automation.PSCredential]::Empty)
        {
            $CredSplat.Add("Credential", $Credential)
        }

		# Get the local domain of the computer running the cmdlet in case it is a domain controller
        $LocalDomain = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain
		$Product = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty ProductType	

		switch ($PSCmdlet.ParameterSetName)
		{
			"Domain" {
				# If the computer running the cmdlet is a domain controller and a different domain wasn't specified
				# then use the DC directly
				if ($Product -eq 2 -and [System.String]::IsNullOrEmpty($Domain))
				{
					$Server = $env:COMPUTERNAME
					$Domain = $LocalDomain
				}
				else
				{
					if ([System.String]::IsNullOrEmpty($Domain))
					{
						$Domain = $LocalDomain
					}

					$Server = Get-ADDomainController -DomainName $Domain -Discover | Select-Object -ExpandProperty Name
					$Splat.Add("ComputerName", $Server)
				}

				break
			}
			"Server" {
				$Domain = $LocalDomain
				$Splat.Add("ComputerName", $Server)
				break
			}
			default {
				throw "The ParameterSet used $($PSCmdlet.ParameterSetName) was not recognized."
			}
		}

        $LocalPath = $FilePath

        # If the targetted server is remote, copy the zip over
		if ($Server.Split(".")[0] -ine $env:COMPUTERNAME -and -not [System.String]::IsNullOrEmpty($FilePath))
		{
			[System.IO.FileInfo]$Info = New-Object -TypeName System.IO.FileInfo($FilePath)

            if (-not (Test-Path -Path "\\$Server\ADMIN$\Temp" @CredSplat))
            {
                New-Item -Path "\\$Server\ADMIN$" -Name "Temp" -ItemType Directory @CredSplat | Out-Null
            }

            $FileName = "$($Info.Name.Substring(0, $Info.Name.LastIndexOf(".")))"
            $Counter = 1
            $TempName = $Info.Name

            while (Test-Path -Path "\\$Name\ADMIN$\Temp\$TempName" @CredSplat)
            {
                $TempName = "$FileName($Counter)$($Info.Extension)"
                $Counter++
            }

            $Destination = "\\$Server\ADMIN$\Temp\$TempName"
                
            Write-Verbose -Message "Copying $FilePath to $Destination."
                    
            Copy-Item -Path $FilePath -Destination $Destination @CredSplat -Force -Confirm:$false
                
            $Sess = New-CimSession -ComputerName $Server @CredSplat
            $LocalPath = Get-CimInstance Win32_Share -Filter "Name = 'ADMIN$'" -CimSession $Sess | Select-Object -ExpandProperty Path
            $LocalPath += "\Temp\$TempName"
            $Sess.Close()           
            Write-Verbose -Message "Copy complete"    
		}

        Invoke-Command -ScriptBlock {
            $SysVol = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters" | Select-Object -ExpandProperty SysVol
			$Domain = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain

            $CentralStoreAdmx = "$SysVol\$Domain\Policies\PolicyDefinitions"
			$CentralStoreAdml = "$SysVol\$Domain\Policies\PolicyDefinitions\en-us"

            if (-not (Test-Path -Path $CentralStoreAdmx))
            {
			    New-Item -ItemType Directory -Path $CentralStoreAdmx | Out-Null
            }

            if (-not (Test-Path -Path $CentralStoreAdml))
            {
			    New-Item -ItemType Directory -Path $CentralStoreAdml | Out-Null
            }
            
			[System.String]$ZipPath = $args[0]

            if ([System.String]::IsNullOrEmpty($ZipPath))
            {
                $SourceAdmx = "$env:SYSTEMROOT\PolicyDefinitions\*.admx"
			    $SourceAdml = "$env:SYSTEMROOT\PolicyDefinitions\en-us\*.adml"

			    Copy-Item -Path $SourceAdmx -Destination $CentralStoreAdmx -Force -Confirm:$false
			    Copy-Item -Path $SourceAdml -Destination $CentralStoreAdml -Force -Confirm:$false
		    }
		    else 
            {
                Add-Type -AssemblyName System.IO.Compression.FileSystem
				
				[System.IO.Compression.ZipArchive]$Zip = [System.IO.Compression.ZipFile]::OpenRead($ZipPath)
                foreach ($Item in $Zip.Entries)
                {
                    [System.IO.Compression.ZipArchiveEntry]$Item = $Item
                    $Target = [System.IO.Path]::Combine($CentralStoreAdmx, $Item.FullName)

					# If the destination file doesn't already exist or if the new file has a later Last Write Time, extract it from the zip
                    if (-not (Test-Path -Path $Target) -or (New-Object -TypeName System.IO.FileInfo($Target)).LastWriteTimeUtc -lt $Item.LastWriteTime.ToUniversalTime().Date)
                    {
                        [System.IO.Compression.ZipFileExtensions]::ExtractToFile($Item, $Target, $true)
                    }
                }
                
                $Zip.Dispose()

                Remove-Item -Path $ZipPath -Force 
		    }

        } -ArgumentList($LocalPath) @Splat @CredSplat -Verbose

        Write-Verbose -Message "Setup complete."
    }

    End {		
    }
}

Function Enable-MSSGPOSettings {
	<#
		.SYNOPSIS
			Adds the new sceregvl.inf file to enable the MSS settings in Group Policy Management.

		.DESCRIPTION
			Adds the new sceregvl.inf file to enable the MSS settings in Group Policy Management. The original file is renamed to .old.

		.PARAMETER FilePath
			The path to the new sceregvl.inf file. If this parameter isn't specified, the default file will be used, which is typically sufficient.

		.INPUTS
			None or System.String
		
		.OUTPUTS
			None

		.EXAMPLE 
			Enable-MSSGPOSettings

			Adds the new sceregvl.inf file and enables the management of MSS settings in GPMC.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, ValueFromPipeline = $true)]
		[ValidateScript({
			Test-Path -Path $_
		})]
		[System.String]$FilePath = [System.String]::Empty
	)

	Begin{		
	}

	Process{
		$TargetFilePath = "$env:SYSTEMROOT\inf\sceregvl.inf"
		$NewName = "$env:SYSTEMROOT\inf\sceregvl.old"

        [System.String]$UserName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

        Set-Owner -Path $TargetFilePath -Account $UserName -Force

        [System.Security.Principal.NTAccount]$NTAccount = New-Object -TypeName System.Security.Principal.NTAccount($UserName)
        [System.Security.Principal.SecurityIdentifier]$Sid = $NTAccount.Translate([System.Security.Principal.SecurityIdentifier])

        $Ace = New-Object System.Security.AccessControl.FileSystemAccessRule($Sid,
            [System.Security.AccessControl.FileSystemRights]::FullControl,
            [System.Security.AccessControl.InheritanceFlags]::None,
            [System.Security.AccessControl.PropagationFlags]::None,
            [System.Security.AccessControl.AccessControlType]::Allow       
        )

        Set-TokenPrivilege -Privileges SeSecurityPrivilege -Enable

		$Acl = Get-Acl -Path $TargetFilePath
		$Acl.AddAccessRule($Ace)
		Set-Acl -Path $TargetFilePath -AclObject $Acl

        $Counter = 1
        $Base = "$env:SYSTEMROOT\inf\"
        $FileName = "sceregvl"
        $Extension = ".inf"

        $Temp = "$Base$FileName$Extension.old"

        while (Test-Path -Path $Temp)
        {
            $Temp = "$Base$FileName($Counter)$Extension.old"
            $Counter++
        }

        Rename-Item -Path $TargetFilePath -NewName $Temp -Force

        if ([System.String]::IsNullOrEmpty($FilePath) -or -not (Test-Path -Path $FilePath))
        {
            Set-Content -Value $script:sceregvl -Path $TargetFilePath -Force
        }
        else
        {
            Copy-Item -Path $FilePath -Destination $TargetFilePath -Force
        }
		
        $RegProcess = Start-Process -FilePath "$env:SYSTEMROOT\System32\regsvr32.exe" -ArgumentList @("/s scecli.dll") -NoNewWindow -Wait -PassThru

        if ($RegProcess.ExitCode -eq 0)
        {
            Write-Verbose -Message "Successfully registered new sceregvl.inf file."
        }
        else
        {
            throw "The new sceregvl.inf file failed to register with regsvr32.exe."
        }
	}

	End{
	}
}

Function Get-ADForestTrust {
	<#
		.SYNOPSIS
			The cmdlet gets the trust relationship information about the local and remote forest.

		.DESCRIPTION
			The cmdlet gets the trust relationship information about the local and remote forest. If no trust exists, the cmdlet returns null.

		.PARAMETER TargetForestName
			The name of the remote forest to get the trust information about.

		.PARAMETER CurrentForest
			The forest object to use to query about the trust information. This defaults to the current forest.

		.INPUTS
			System.String
		
		.OUTPUTS
			System.DirectoryServices.ActiveDirectory.ForestTrustRelationshipInformation

		.EXAMPLE 
			Get-ADForestTrust -TargetForestName "contoso.com"

			Gets trust relationship information about contoso.com and the local forest.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
    [CmdletBinding()]
	[OutputType([System.DirectoryServices.ActiveDirectory.ForestTrustRelationshipInformation])]
    Param(
		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
        [System.String]$TargetForestName,

		[Parameter(Position = 1)]
		[ValidateNotNull()]
        [System.DirectoryServices.ActiveDirectory.Forest]$CurrentForest = $null
    )

    Begin {		
	}

    Process {
		if ($CurrentForest -eq $null) {
			$CurrentForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
		}

		try {
			Write-Output -InputObject $CurrentForest.GetTrustRelationship($TargetForestName)
		}
		catch [System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException] {
			Write-Warning -Message $_.Exception.Message
			Write-Output -InputObject $null
		}
    }

	End {}
}

Function Set-ADForestTrustSIDFiltering {
	<#
		.SYNOPSIS
			The cmdlet sets SID filtering between two forests.

		.DESCRIPTION
			The cmdlet enables or disables SID filtering between two forests with a forest trust.

		.PARAMETER TrustingForest
			The forest object that trusts the other forest. The trust direction would be outbound or bidirectional for this forest. This defaults to the current forest.

		.PARAMETER TrustedForest
			The forest that is trusted by the other forest. The trust direction would be inbound or bidirectional for this forest.

		.PARAMETER SidFilteringEnabled
			Specify whether SID filtering should be enabled. This defaults to true.

		.INPUTS
			System.String
		
		.OUTPUTS
			None

		.EXAMPLE 
			Set-ADForestTrustSIDFiltering -TrustedForest "contoso.com" 

			The local forest, admin.local, that trusts contoso.com, has SID filtering enabled on the trust.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, ValueFromPipeline = $true, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$TrustedForest,

		[Parameter(Position = 1)]
		[ValidateNotNull()]
		[System.DirectoryServices.ActiveDirectory.Forest]$TrustingForest = $null,

		[Parameter(Position = 2)]
		[System.Boolean]$SidFilteringEnabled = $true
	)

	Begin {		
	}

	Process {
		if ($TrustingForest -eq $null) {
			$TrustingForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()
		}

		try {
			Write-Verbose -Message "Setting SID Filtering for $($TrustingForest.Name) to $SidFilteringEnabled."
			$TrustingForest.SetSidFilteringStatus($TrustedForest, $SidFilteringEnabled)
			Write-Verbose -Message "Successfully set SID Filtering to $SidFilteringEnabled."
		}
		catch [Exception] {
			Write-Warning -Message $_.Exception.Message
		}
	}

	End {
	}
}

Function Set-ADForestTrustKerberosAESEncryption {
	<#
		.SYNOPSIS
			The cmdlet enables Kerberos AES 128 and 256 encryption for a forest trust.

		.DESCRIPTION
			The cmdlet uses ksetup.exe to enables AES 128 and 256 encryption in the forest specified. 
	
			An inbound trust enables encryption in the local forest, outbound in the remote forest, and bidirectional
			in both forests.

			###################################################################################################
	
			On inbound trusts, the remote forest trusts this local forest, so we need to setup the local forest
		    to issue KDC tickets with AES encryption
		
		             Direction Of Trust (Inbound)
		                    ---------->
		    RemoteForest.com            LocalForest.com
		                    <----------
		             Direction of Access (Outbound)
           
            
            On outbound trusts, this forest trusts the remote forst, so we need to setup the remote forest
		    to issue KDC tickets with AES encryption
		
		             Direction Of Trust (Outbound)
		                  <---------
		    RemoteForest.com            LocalForest.com
		                  ---------->
		             Direction of Access (Inbound)

			###################################################################################################

            The TrustedForest parameter should be the source of access, so for an INBOUND trust, the LOCAL forest, for an OUTBOUND trust, the REMOTE forest.

            For a BIDIRECTIONAL trust, you should run this cmdlet twice, once for each forest in the trust as the TRUSTED Forest.
		
		.PARAMETER TrustingForest
			The name of the TRUSTING forest (i.e. the source of access of the INBOUND side of the forest trust).

        .PARAMETER TrustedForest
            The name of the TRUSTED forest (i.e. the target of access of the OUTBOUND side of the forest trust). This is where the command will be executed.

		.PARAMETER IncludeRC4
			This parameter will include the RC4 encryption algorithm with AES options for compatibility.

		.PARAMETER Server
			The domain controller to connect to in order to run ksetup. If this is not specified, a DC is discovered in the forest root domain. 
            The user must have credentials to connect to the server via WinRM and run ksetup.
			
		.PARAMETER Credential
			The credential used to connect to a domain controller in the forest root domain on the TRUSTING forest side.

		.PARAMETER PassThru
			Returns the new or modified object. By default (i.e. if -PassThru is not specified), this cmdlet does not generate any output.
	
		.INPUTS
			None
		
		.OUTPUTS
			None or Microsoft.ActiveDirectory.Management.ADObject

		.EXAMPLE 
			Set-ADForestTrustKerberosAESEncryption -TrustingForest "tailspintoys.com" -TrustedForest "contoso.com" -Credential (Get-Credential)

			Prompts the user for credentials for the contoso.com domain. Sets up AES kerberos encryption in the contoso.com domain for the INBOUND forest trust from tailspintoys.com

    	.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/23/2017
	#>
	[CmdletBinding(DefaultParameterSetName = "Forest")]
	[OutputType([Microsoft.ActiveDirectory.Management.ADObject])]
	Param(
        [Parameter(Mandatory = $true, Position = 0, ParameterSetName = "Forest")]
        [ValidateNotNullOrEmpty()]
        [System.String]$TrustingForest,

        [Parameter(Mandatory = $true, Position = 1)]
        [ValidateNotNullOrEmpty()]
        [System.String]$TrustedForest,

		[Parameter()]
		[Switch]$IncludeRC4,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter(ParameterSetName = "Forest")]
        [Parameter(Mandatory = $true, Position = 0, ParameterSetName = "Server")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Server = [System.String]::Empty,

		[Parameter()]
		[Switch]$PassThru
	)

	Begin {		
	}

	Process {
        # Get the local domain of the computer running the cmdlet in case it is a domain controller
        $LocalDomain = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain
		$Product = Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty ProductType	
        
        [System.Collections.Hashtable]$Splat = @{}

        if ($PSCmdlet.ParameterSetName -eq "Forest")
        {
            # If we only specify a forest and no server, find a domain controller
            if ([System.String]::IsNullOrEmpty($Server))
            {
                if (-not ($Product -eq 2 -and $LocalDomain -eq $TrustedForest))
                {
                    $Server = Get-ADDomainController -DomainName $TrustingForest -Discover | Select-Object -ExpandProperty Name
				    $Splat.Add("ComputerName", $Server)
                }
                # else, this will run locally
            }
            else
            {
                # Otherwise, we've specified a server in the forest, so use that explicitly
                $Splat.Add("ComputerName", $Server)
            }
        }
		else
        {
            # Otherwise, we've specified a server in the forest, so use that explicitly
            $Splat.Add("ComputerName", $Server)
        }

		if ($Credential -ne [System.Management.Automation.PSCredential]::Empty)
		{
			$Splat.Add("Credential", $Credential)
		}

		[System.Boolean]$RC4 = $IncludeRC4
        
        $Trust = Invoke-Command -ScriptBlock {
			    Import-Module -Name ActiveDirectory
				$KSetupArgs = @("/setenctypeattr",$args[0],"AES128-CTS-HMAC-SHA1-96","AES256-CTS-HMAC-SHA1-96")
				[System.Boolean]$IncludeRC4 = $args[1]

				if ($IncludeRC4 -eq $true)
				{
					$KSetupArgs += "RC4-HMAC-MD5"
				}

			    Start-Process -FilePath "$env:SYSTEMROOT\system32\ksetup.exe" -ArgumentList $KSetupArgs -NoNewWindow -Wait
				[System.String]$Name = $args[0]
			    Write-Output -InputObject (Get-ADObject -Filter {(objectClass -eq "trustedDomain") -and (name -eq $Name)} -Properties "msDS-SupportedEncryptionTypes") 
		    } -ArgumentList @($TrustingForest, $RC4) -ErrorVariable Errs @Splat

		if ($Errs -ne $null -and $Errs.Length -gt 0) 
		{
			foreach ($Err in $Errs)
			{
				Write-Error -ErrorRecord $Err
			}
		}
		else
		{
			if ($PassThru) {
				Write-Output -InputObject $Trust
			}
		}
	}

	End {
	}
}

Function Get-ADForestTrustSelectiveAuthentication {
	<#

	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, Mandatory = $true, ParameterSetName = "Object")]
		[ValidateNotNull()]
		[System.DirectoryServices.ActiveDirectory.Forest]$TrustingForest,

		[Parameter(Position = 0, Mandatory = $true, ParameterSetName = "Name")]
		[ValidateNotNullOrEmpty()]
		[System.String]$TrustingForestName,

		[Parameter(Position = 1, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$TrustedForest,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		if ($PSCmdlet.ParameterSetName -eq "Name")
		{
			Write-Verbose -Message "Creating a DirectoryContext from Forest name."
			if ($Credential -ne [System.Management.Automation.PSCredential]::Empty) {
				[System.DirectoryServices.ActiveDirectory.DirectoryContext]$TrustingForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $TrustingForestName, $Credential.UserName, (Convert-SecureStringToString -SecureString $Credential.Password))
			}
			else {
				[System.DirectoryServices.ActiveDirectory.DirectoryContext]$TrustingForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $TrustingForestName)
			}

			Write-Verbose -Message "Creating the forest object."
			$TrustingForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($TrustingForestContext)
		}

		Write-Verbose -Message "Getting selective authentication."

		Write-Output -InputObject ($TrustingForest.GetSelectiveAuthenticationStatus($TrustedForest))
	}

	End {
	}
}

Function Set-ADForestTrustSelectiveAuthentication {
	<#

	#>
	[CmdletBinding()]
	[OutputType()]
	Param(
		[Parameter(Position = 0, Mandatory = $true, ParameterSetName = "Object")]
		[ValidateNotNull()]
		[System.DirectoryServices.ActiveDirectory.Forest]$TrustingForest,

		[Parameter(Position = 0, Mandatory = $true, ParameterSetName = "Name")]
		[ValidateNotNullOrEmpty()]
		[System.String]$TrustingForestName,

		[Parameter(Position = 1, Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String]$TrustedForest,

		[Parameter(Position = 2)]
		[System.Boolean]$Enabled = $true,

		[Parameter()]
		[ValidateNotNull()]
		[System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty
	)

	Begin {
	}

	Process {
		if ($PSCmdlet.ParameterSetName -eq "Name")
		{
			Write-Verbose -Message "Creating a DirectoryContext from Forest name."
			if ($Credential -ne [System.Management.Automation.PSCredential]::Empty) {
				[System.DirectoryServices.ActiveDirectory.DirectoryContext]$TrustingForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $TrustingForestName, $Credential.UserName, (Convert-SecureStringToString -SecureString $Credential.Password))
			}
			else {
				[System.DirectoryServices.ActiveDirectory.DirectoryContext]$TrustingForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $TrustingForestName)
			}

			Write-Verbose -Message "Creating the forest object."
			$TrustingForest = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($TrustingForestContext)
		}

		Write-Verbose -Message "Setting selective authentication."

		$TrustingForest.SetSelectiveAuthenticationStatus($TrustedForest, $Enabled)

		Write-Verbose -Message "Completed setting selective authentication."
	}

	End {

	}
}

Function New-ADForestTrust {
	<#
		.SYNOPSIS
			The cmdlet builds a forest trust between two forests.

		.DESCRIPTION
			The cmdlet creates a forest trust between two forests and configures settings associated with the trust. The command will remove existing trust objects with the same name if they are discovered. Because the 
			Microsoft function for trusts only checks the NetBIOS name when it checks for existence, a trust for another forest could inadvertently be removed. For example, if the local forest is admin.local and the remote 
			forest has a trust to admin.com, building the trust would fail.

		.PARAMETER LocalForest
			The name of the local forest where the cmdlet is being run. This defaults to the forest root domain of the computer running the cmdlet.

		.PARAMETER RemoteForest
			The name of the remote forest where the trust will connect.

		.PARAMETER TrustDirection
			The direction of the forest trust in relation to the server the cmdlet is being run on. This can be Inbound, Outbound, or Bidirectional.

		.PARAMETER LocalForestCredential
			The credential to use to setup the local side of the trust. The credential should have Enterprise Admin rights and defaults to the user running the cmdlet.

        .PARAMETER ForestTrustPassword
            The password that will be specified on both sides of the trust if the trust is being created one side at a time. If this is not specified and a remote credential
            is not specified, a new random password will be created and returned to the pipeline.

		.PARAMETER RemoteForestCredential
			The credential to use to setup the remote side of the trust. The credential should have Enterprise Admin rights in the remote forest.

            If these credentials are not specified, only half of the trust will be setup (the local forest side) and you will need to create the rest of the trust in
            the other forest. For example, if you were to create an inbound trust for the local forest, you would need to configure an outbound trust in the remote forest separately.

		.PARAMETER EnableSelectiveAuthentication
			Specify whether selective authentication is enabled for the trusting forest. In the case of a bidirectional trust, this is both forests.

            For an inbound or bidirectional trust, this parameter requires RemoteForestCredentials.

		.PARAMETER SidFilteringEnabled
			Specify whether SID filtering is enabled for the trusting forest. In the case of a bidirectional trust, this is both forests.

            For an inbound or bidirectional trust, this parameter requires RemoteForestCredentials.

		.PARAMETER CreateLocalConditionalForwarder
			Specifies whether to create a DNS conditional forwarder in the local forest in order to resolve the remote forest DNS name.

		.PARAMETER RemoteForestMasterServers
			The IP addresses of the remote forest DNS servers that the local conditional forwarder will point to. This is required if the CreateLocalConditionalForwarder is specified.

		.PARAMETER CreateRemoteConditionalForwarder
			Specifies whether to create a DNS conditional forwarder in the remote forest in order to resolve the local forest DNS name.

		.PARAMETER TrustingDomainSupportsKerberosAESEncryption
			Specifies whether the trusting domain supports Kerberos AES Encryption. When the trusting domain supports it, it must be configured in the TRUSTED domain so that
            KDC tickets are passed to the trusting domain using AES encyption. In the case of a bidirectional trust, this specifies that each side of the trust supports AES Encryption.

            For an outbound or bidirectional trust, this parameter requires RemoteForestCredentials.

		.INPUTS
			None
		
		.OUTPUTS
			None

		.EXAMPLE 
			New-ADForestTrust -RemoteForest "contoso.com" -RemoteForestCredential (Get-Credential) -CreateLocalConditionalForwarder -CreateRemoteConditionalForwarder -RemoteForestMasterServers @("192.168.2.1")

			Creates conditional forwarders in both the remote and local forest and establishes an inbound forest trust.

		.NOTES
			AUTHOR: Michael Haken
			LAST UPDATE: 10/27/2017
	#>
	[CmdletBinding()]
    [OutputType()]
	Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
		[System.String]$RemoteForest,

        [Parameter(Position = 1, Mandatory = $true)]
        [ValidateNotNull()]
		[System.DirectoryServices.ActiveDirectory.TrustDirection]$TrustDirection,

        [Parameter()]
        [ValidateNotNullOrEmpty()]
        [System.String]$ForestTrustPassword,

        [Parameter()]
		[ValidateNotNull()]
        [System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$RemoteForestCredential = [System.Management.Automation.PSCredential]::Empty,

		[Parameter()]
        [ValidateNotNullOrEmpty()]
		[System.String]$LocalForest = [System.String]::Empty,

		[Parameter()]
		[ValidateNotNull()]
        [System.Management.Automation.Credential()]
		[System.Management.Automation.PSCredential]$LocalForestCredential = [System.Management.Automation.PSCredential]::Empty,
		
		[Parameter()]
		[Switch]$EnableSelectiveAuthentication,

		[Parameter()]
		[Switch]$SidFilteringEnabled,

		[Parameter(ParameterSetName = "Local")]
		[Switch]$CreateLocalConditionalForwarder = $false,

		[Parameter(ParameterSetName = "Local", Mandatory = $true)]
		[ValidateNotNullOrEmpty()]
		[System.String[]]$RemoteForestMasterServers,

        [Parameter()]
        [Switch]$CreateRemoteConditionalForwarder = $false,

        [Parameter()]
        [Switch]$TrustingDomainSupportsKerberosAESEncryption
	)

	Begin {		
	}

	Process {
        if ($CreateRemoteConditionalForwarder -and $RemoteForestCredential -eq [System.Management.Automation.PSCredential]::Empty)
        {
            throw (New-Object -TypeName System.Exception("In order to create the remote forest conditional forwarder, you must supply non-empty remote forest credentials."))
        }

        if ($EnableSelectiveAuthentication -and $RemoteForestCredential -eq [System.Management.Automation.PSCredential]::Empty -and @([System.DirectoryServices.ActiveDirectory.TrustDirection]::Inbound, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional) -contains $TrustDirection)
        {
            throw (New-Object -TypeName System.Exception("In order to enable selective authentication for an outbound or bidirectional trust, you must supply non-empty remote forest credentials."))
        }

        if ($SidFilteringEnabled -and $RemoteForestCredential -eq [System.Management.Automation.PSCredential]::Empty -and @([System.DirectoryServices.ActiveDirectory.TrustDirection]::Inbound, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional) -contains $TrustDirection)
        {
            throw (New-Object -TypeName System.Exception("In order to enable SID filtering for an outbound or bidirectional trust, you must supply non-empty remote forest credentials."))
        }

        if ($TrustingDomainSupportsKerberosAESEncryption -and $RemoteForestCredential -eq [System.Management.Automation.PSCredential]::Empty -and @([System.DirectoryServices.ActiveDirectory.TrustDirection]::Outbound, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional) -contains $TrustDirection)
        {
            throw (New-Object -TypeName System.Exception("In order to enable kerberos AES encryption for an inbound or bidirectional trust, you must supply non-empty remote forest credentials."))
        }

        $ShouldContinue = $true

		if ([System.String]::IsNullOrEmpty($LocalForest)) {
			$LocalForest = (Get-ADForest -Current LoggedOnUser).RootDomain
		}

		if ($CreateLocalConditionalForwarder -and $RemoteForestMasterServers.Count -lt 1) {
			throw "The create local conditional forwarder was specified, but no remote master servers were specified."
		}

		if ($LocalForestCredential -ne [System.Management.Automation.PSCredential]::Empty) {
			[System.DirectoryServices.ActiveDirectory.DirectoryContext]$LocalForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $LocalForest, $LocalForestCredential.UserName, (Convert-SecureStringToString -SecureString $LocalForestCredential.Password))
		}
		else {
            [System.DirectoryServices.ActiveDirectory.DirectoryContext]$LocalForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $LocalForest)
		}

        [System.DirectoryServices.ActiveDirectory.Forest]$LocalForestObj = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($LocalForestContext)

        if ($CreateLocalConditionalForwarder)
        {
            if (([Microsoft.Management.Infrastructure.CimInstance]$Zone = Get-DnsServerZone -Name $RemoteForest -ErrorAction SilentlyContinue) -eq $null)
            {
                Write-Verbose -Message "Remote forest does not have an existing local DNS zone."

                [System.Int32]$Counter = 0
				while ($true) {
				    try {
					    Add-DnsServerConditionalForwarderZone -Name $RemoteForest -MasterServers $RemoteForestMasterServers -ReplicationScope Forest -ComputerName $LocalForestObj.Name
					    Write-Verbose -Message "Conditional forwarder for $RemoteForest successfully created."
					    break
				    }
				    catch [Exception] {
					    if ($Counter -gt 10) {
                            $ShouldContinue = $false
						    throw $_.Exception
					    }
					    else {										
						    Write-Warning -Message "Failed to create conditional forwarder on attempt $($Counter + 1)."
						    Write-Warning -Message "$($_.Exception.Message)"
						    $Counter++
						    Start-Sleep -Seconds 10
					    }
				    }
			    }
            }
            else
            {
                Write-Verbose -Message "A DNS $($Zone.ZoneType) for the remote forest already exists, no need to create a conditional forwarder."
            }
        }

        if ($RemoteForestCredential -ne [System.Management.Automation.PSCredential]::Empty)
        {
            try {
			    Write-Verbose -Message "Ensuring the remote forest name provided $RemoteForest is actually the forest root."
			    $RemoteForest = (Get-ADDomain -Identity $RemoteForest -Credential $RemoteForestCredential).Forest
			    Write-Verbose -Message "Forest root is confirmed as $RemoteForest."
		    }
		    catch [Exception] {
			    Write-Warning -Message "Error getting remote forest root: $($_.Exception.Message)"
			    $ShouldContinue = $false
		    }
        }

        if ($ShouldContinue -and $CreateRemoteConditionalForwarder)
        {
            if ($RemoteForestCredential -ne [System.Management.Automation.PSCredential]::Empty)
            {
                Write-Verbose -Message "Beginning remote forest conditional forwarder setup to $($LocalForestObj.Name)."
                Write-Verbose -Message "Querying LDAP servers in the remote forest."
            
                # The server NameTarget property is an FQDN
                [System.String[]]$Servers = Resolve-DnsName -Name "_ldap._tcp.dc._msdcs.$RemoteForest" -Type SRV | Where-Object {$_.Type -eq "SRV"} | Select-Object -ExpandProperty NameTarget 
            
                Write-Verbose -Message "Found $([System.String]::Join(",", $Servers)) as LDAP server$(if($Servers.Length -gt 1) { "s" }) in $RemoteForest."
                [System.String]$RemoteServer = [System.String]::Empty

                foreach ($Server in $Servers)
                {
                    Write-Verbose -Message "Testing connectivity to $Server"

                    if (Test-Connection -ComputerName $Server -Count 1 -Quiet)
                    {
                        Write-Verbose -Message "Successfully connected to $Server."
                    
                        # We'll use this server to connect to in order to setup the conditional forwarder
                        $RemoteServer = $Servers

                        # Break out of the loop, we don't need to test anymore servers
                        break
                    }
                    else
                    {
                        Write-Verbose -Message "Could not connect to $Server."
                    }
                }

                if (-not [System.String]::IsNullOrEmpty($RemoteServer))
                {
                    # This stage will get the IP addresses of the NS servers in the local forest

                    Write-Verbose -Message "Getting list of master servers in $($LocalForestObj.Name) to create in the remote forest conditional forwarder."
				    [System.String[]]$LocalMasterServers = @()

                    try
                    {
				        Resolve-DnsName -Name $LocalForestObj.Name -Type NS | Where-Object {-not [System.String]::IsNullOrEmpty($_.NameHost)} | Select-Object -ExpandProperty NameHost | ForEach-Object {
        			        # The NS record returned is
                            # Name     : admin.local
                            # Type     : NS
                            # TTL      : 3600
                            # Section  : Answer
                            # NameHost : dc1.admin.local
                            #
                            # Resolve the name host to an IP address to include in the remote conditional forwarder

                            try
                            {
                                $Name = $_
                                $LocalMasterServers += (Resolve-DnsName -Name $Name -Type A | Select-Object -ExpandProperty IPAddress)
                            }
                            catch [Exception]
                            {
                                Write-Verbose -Message "The was an exception resolving $Name : $($_.Exception.Message)"
                            }
				        }
                    }
                    catch [Exception]
                    {
                        Write-Warning -Message "There was an exception resolving the NS records for $($LocalForestObj.Name) : $($_.Exception.Message)"
                        $ShouldContinue = $false
                    }

                    # Once the NS server IPs have been identified, connect to the remote server and setup the forwarder
                    if ($LocalMasterServers.Length -gt 0)
                    {                                                                                                                                                                                                   
                        Write-Verbose -Message "The local master server$(if ($LocalMasterServers.Length -gt 1) { "s" }) to be included in the conditional forwarder are $([System.String]::Join(",", $LocalMasterServers))."
                        Write-Verbose -Message "Connecting to $RemoteServer."

                        [System.Management.Automation.Runspaces.PSSession]$Session = New-PSSession -ComputerName $RemoteServer -Credential $RemoteForestCredential -ErrorAction Stop

                        Write-Verbose -Message "Executing DNS setup on $RemoteServer."

                        [Microsoft.Management.Infrastructure.CimInstance]$Result = Invoke-Command -Session $Session -ScriptBlock {
					        Import-Module -Name DnsServer
                        
                            # Check to see if a zone exists already, if it doesn't, create a conditional forwarder, if it does,
                            # then update it to use the list of master servers we just
                            [Microsoft.Management.Infrastructure.CimInstance]$Zone = Get-DnsServerZone -Name $args[0] -ErrorAction SilentlyContinue
						
                            if ($Zone -eq $null) 
                            {
				                $Zone = Add-DnsServerConditionalForwarderZone -Name $args[0] -MasterServers $args[1] -ReplicationScope Forest -PassThru
					        }
					        else 
                            {
                                [System.String[]]$Current = $Zone.MasterServers | Select-Object -ExpandProperty IPAddressToString
                                [System.String[]]$Combined = $Current + $args[1]
						        switch ($Zone.Type) {
							        "Forwarder" {                                    
								        $Zone = Set-DnsServerConditionalForwarderZone -Name $args[0] -MasterServers $Combined -PassThru
								        break
							        }
							        "Stub" {
								        $Zone = Set-DnsServerStubZone -Name $args[0] -MasterServers $Combined -PassThru
								        break
							        }
							        default {
								        break
							        }
						        }	
					        }

                            Write-Output -InputObject $Zone
				        } -ErrorVariable ErrResult -ArgumentList @($LocalForestObj.Name, $LocalMasterServers)

					    Remove-PSSession -Session $Session

                        if ($ErrResult -ne $null -and $ErrResult.Count -gt 0) 
                        {
						    $ShouldContinue = $false
                            
                            Write-Warning -Message "Failed to setup remote forest conditional forwarder."

                            foreach ($Err in $ErrResult)
                            {
                                Write-Warning -Message $Err.Exception.Message
                            }
					    }
					    else 
                        {
						    Write-Verbose -Message "Successfully created remote forest conditional forwarder.`r`n$($Result | Format-List | Out-String)"
					    }
                    }
                    else
                    {
                        Write-Warning -Message "No local master servers could be identified from DNS."
                        $ShouldContinue = $false
                    }
                }
                else
                {
                    Write-Warning -Message "Unable to connect to any remote forest server to perform the conditional forwarder setup."
                    $ShouldContinue = $false
                }
            }
        }

        if ($ShouldContinue)
        {
            $LocalNetbios = $LocalForestObj.Name.Substring(0, $LocalForestObj.Name.IndexOf("."))
			$RemoteNetbios = $RemoteForest.Substring(0, $RemoteForest.IndexOf("."))

            # Test for the existence of the trust on the local side
			# Assume trust existsand prove otherwise
			$LocalExists = $true

            Write-Verbose -Message "Testing for an existing forest trust in the local forest."
            
            try
            {
                $LocalTrust = Get-ADForestTrust -TargetForestName $RemoteNetbios -CurrentForest $LocalForestObj

                if ($LocalTrust -eq $null) {
					$LocalExists = $false
                    Write-Verbose -Message "Local forest trust for $RemoteNetbios does not exist."
				}
                else {
                    Write-Verbose -Message "Local forest trust for $RemoteNetbios does exist and will be re-created."
                }
            }
            catch [Exception]
            {
                Write-Warning -Message "Exception getting information about existing trust in local forest: $($_.Exception.Message). Assuming it does not exist."
                $LocalExists = $false
            }


            # In this case, we're only going to setup half of the trust
            if ($RemoteForestCredential -eq [System.Management.Automation.PSCredential]::Empty)
            {
                Write-Verbose -Message "Remote credentials not specified, creating local side of forest trust only."

                [System.Boolean]$SendToPipeline = $false
                if ([System.String]::IsNullOrEmpty($ForestTrustPassword))
                {
                    Write-Verbose -Message "Creating new random password for the fores trust."
                    $ForestTrustPassword = New-RandomPassword -Length 50 -EnforceComplexity
                    $SendToPipeline = $true
                }

                try
                {
                    if ($LocalExists)
                    {
                        Write-Verbose -Message "Deleting existing local side of trust relationship."

                        try
                        {
                            $LocalForestObj.DeleteLocalSideOfTrustRelationship($RemoteNetbios)
                        }
                        catch [Exception]
                        {
                            throw (New-Object -TypeName System.Exception("Could not delete existing local side of the trust relationship: $($_.Exception.Message)."))
                        }
                    }

                    Write-Verbose -Message "Creating local side of trust relationship."

                    $LocalForestObj.CreateLocalSideOfTrustRelationship($RemoteForest, $TrustDirection, $ForestTrustPassword)

                    Write-Verbose -Message "Successfully created the local side of the trust relationship."

                    
                    # Enable additional trust options

                    # Inbound and Bidirectional
				    if (@([System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Inbound) -contains $TrustDirection) 
                    {
                        # Local forest is trusted by remote forest
                        # Inbound for Local Forest - Setup AES encryption support
                        # Outbound for Remote Forest - Setup SID filtering and selective authentication


                        # No selective authentication, requires remote forest credentials
                    
                        # No SID filtering, requires remote forest credentials

                        if ($TrustingDomainSupportsKerberosAESEncryption)
                        {
                            try
                            {
                                Write-Verbose -Message "Enabling AES kerberos encryption in the remote forest."
                                Set-ADForestTrustKerberosAESEncryption -TrustingForest $RemoteForestObj.Name -TrustedForest $LocalForestObj.Name -Credential $RemoteForestCredential
                                Write-Verbose -Message "Successfully enabled AES kerberos encryption."
                            }
                            catch [Exception]
                            {
                                Write-Warning -Message "Could not enable AES kerberos encryption in the remote forest: $($_.Exception.Message)."
                            }
                        }
				    }
				
                    # Outbound and Bidirectional
	                if (@([System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Outbound) -contains $TrustDirection) 
                    {
                        # Local forest trusts the remote forest
                        # Outbound for Local Forest - Setup SID filtering and selective authentication
                        # Outbound for Remote Forest - Setup AES encryption support

                        if ($EnableSelectiveAuthentication)
                        {
                            try
                            {
                                Write-Verbose -Message "Enabling selective authentication from $($RemoteForestObj.Name) to $($LocalForestObj.Name)."
                                Set-ADForestTrustSelectiveAuthentication -TrustingForest $LocalForestObj -TrustedForest $RemoveForestObj.Name -Enabled $true -Credential $RemoteForestCredential
                                Write-Verbose -Message "Successfully enabled selective authentication."
                            }
                            catch [Exception]
                            {
                                Write-Warning -Message "Could not establish selective authentication from $($RemoteForestObj.Name) to $($LocalForestObj.Name) : $($_.Exception.Message)."
                            }
                        }

                        if ($SidFilteringEnabled)
                        {
                            try
                            {
                                Write-Verbose -Message "Enabling SID filtering on local forest for an outbound trust."
						        Set-ADForestTrustSIDFiltering -TrustingForest $LocalForestObj -TrustedForest $RemoteForestObj.Name -SidFilteringEnabled $SidFilteringEnabled
                                Write-Verbose -Message "Successfully enabled SID filtering."
                            }
                            catch [Exception]
                            {
                                Write-Warning -Message "Could not enable SID filtering on the local forest: $($_.Exception.Message)."
                            }
                        }

                        # No AES encryption support, requires remote forest credentials
				    }
                    
                    if ($SendToPipeline)
                    {
                        Write-Output -InputObject $ForestTrustPassword
                    }
                }
                catch [Exception]
                {
                    throw (New-Object -TypeName System.Exception("Failed to setup the local side of the trust relationship: $($_.Exception.Message)."))
                }
            }
            # We have credentials, so we can setup both sides of the trust
            else
            {
                try {
				    [System.DirectoryServices.ActiveDirectory.DirectoryContext]$RemoteForestContext = New-Object -TypeName System.DirectoryServices.ActiveDirectory.DirectoryContext([System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest, $RemoteForest, $RemoteForestCredential.UserName, (Convert-SecureStringToString -SecureString $RemoteForestCredential.Password))
				    [System.DirectoryServices.ActiveDirectory.Forest]$RemoteForestObj = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($RemoteForestContext)
			    }
			    catch [Exception] {
				    throw (New-Object -TypeName System.Exception("Could not create the remote forest ActiveDirectory object : $($_.Exception.Message)"))
			    }

                # Test for the existence of the trust on the remote side
			    # Assume trust exists on the far side and prove otherwise
			    $RemoteExists = $true
    
                Write-Verbose -Message "Testing for an existing forest trust in the remote forest."
            
                try
                {
                    $RemoteTrust = Get-ADForestTrust -TargetForestName $LocalNetbios -CurrentForest $RemoteForestObj

                    if ($RemoteTrust -eq $null) {
					    $RemoteExists = $false
                        Write-Verbose -Message "Remote forest trust for $LocalNetbios does not exist."
				    }
                    else {
                        Write-Verbose -Message "Remote forest trust for $LocalNetbios does exist and will be re-created."
                    }
                }
                catch [Exception]
                {
                    Write-Warning -Message "Exception getting information about existing trust in remote forest: $($_.Exception.Message). Assuming it does not exist."
                    $RemoteExists = $false
                }

                # Pre-existing trust cleanup
                try
                {
                    Write-Verbose -Message "Cleaning up any pre-existing trust relationships."
                    $Counter = 1

                    while ($true)
                    {
                        try
                        {
                            # Option 1, A trust already exists on both sides
                            if ($RemoteExists -and $LocalExists)
                            {
                                $LocalForestObj.DeleteTrustRelationship($RemoteForestObj)
                                Write-Verbose -Message "Successfully deleted trust relationship from both sides."
                                break
                            }
                            # Option 2, trust already exists on remote side
                            elseif ($RemoteExists)
                            {
                                $RemoteForestObj.DeleteLocalSideOfTrustRelationship($LocalForestObj.Name)
                                Write-Verbose -Message "Successfully deleted trust relationship on local side of the remote forest."
                                break
                            }
                            # Option 3, trust already exists on local side
                            elseif ($LocalExists)
                            {
                                $LocalForestObj.DeleteLocalSideOfTrustRelationship($RemoteForestObj.Name)
                                Write-Verbose -Message "Successfully deleted trust relationship on local side of the local forest."
                                break
                            }
                            # Option 4, nothing is pre-existing
                            else
                            {
                                # Do nothing, not sides of the trust exist
                                Write-Verbose -Message "No pre-existing trust relationships on either side of the forest."
                                break
                            }
                        }
                        catch [System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException] 
                        {
					        Write-Warning -Message "The trust object could not be found for deletion : $($_.Exception.Message). Assuming it was deleted before the cmdlet got to it."
                            break
				        }
                        catch [Exception]
                        {
                            if ($Counter -gt 60)
                            {
                                Write-Warning -Message "Maximum number of deletion attempts exceeded."
                                throw $_.Exception
                            }
                            else
                            {
                                Write-Verbose -Message "Failed to delete trust relationship on attempt $Counter with exception : $($_.Exception.Message)."
                                Start-Sleep -Seconds 1
                                $Counter++
                            }
                        }
                    }
                }
                catch [Exception]
                {
                    throw (New-Object -TypeName System.Exception("Could not remove existing trust : $($_.Exception.Message)"))
                }

                # Build forest trust
                try
                {
                    $LocalForestObj.CreateTrustRelationship($RemoteForestObj, $TrustDirection)

				    Write-Verbose -Message "Trust creation completed, verifying trust."
                }
                catch [Exception]
                {
                    throw (New-Object -TypeName System.Exception("The trust relationship could not be established: $($_.Exception.Message)."))
                }

                # Verify forest trust
                try
                {
				    $LocalForestObj.VerifyTrustRelationship($RemoteForestObj, $TrustDirection)

				    Write-Verbose "Trust creation verified."
                }
                catch [System.DirectoryServices.ActiveDirectory.ActiveDirectoryObjectNotFoundException] 
                {
                    throw (New-Object -TypeName System.Exception("The trust relationship could not be verified: $($_.Exception.Message)."))
                }

                # Enable additional trust options

                # Inbound and Bidirectional
				if (@([System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Inbound) -contains $TrustDirection) 
                {
                    # Local forest is trusted by remote forest
                    # Inbound for Local Forest - Setup AES encryption support
                    # Outbound for Remote Forest - Setup SID filtering and selective authentication


                    if ($EnableSelectiveAuthentication)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling selective authentication from $($LocalForestObj.Name) to $($RemoteForestObj.Name)."
                            Set-ADForestTrustSelectiveAuthentication -TrustingForest $RemoteForestObj -TrustedForest $LocalForestObj.Name -Enabled $true
                            Write-Verbose -Message "Successfully enabled selective authentication."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not establish selective authentication from $($RemoteForestObj.Name) to $($LocalForestObj.Name) : $($_.Exception.Message)."
                        }
                    }
                    
                    if ($SidFilteringEnabled)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling SID filtering on remote forest for an inbound trust."
					        Set-ADForestTrustSIDFiltering -TrustingForest $RemoteForestObj -TrustedForest $LocalForestObj.Name -SidFilteringEnabled $SidFilteringEnabled
                            Write-Verbose -Message "Successfully enabled SID filtering."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not enable SID filtering on the remtoe forest: $($_.Exception.Message)."
                        }
                    }

                    if ($TrustingDomainSupportsKerberosAESEncryption)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling AES kerberos encryption in the remote forest."
                            Set-ADForestTrustKerberosAESEncryption -TrustingForest $RemoteForestObj.Name -TrustedForest $LocalForestObj.Name -Credential $RemoteForestCredential
                            Write-Verbose -Message "Successfully enabled AES kerberos encryption."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not enable AES kerberos encryption in the remote forest: $($_.Exception.Message)."
                        }
                    }
				}
				
                # Outbound and Bidirectional
	            if (@([System.DirectoryServices.ActiveDirectory.TrustDirection]::Bidirectional, [System.DirectoryServices.ActiveDirectory.TrustDirection]::Outbound) -contains $TrustDirection) 
                {
                    # Local forest trusts the remote forest
                    # Outbound for Local Forest - Setup SID filtering and selective authentication
                    # Outbound for Remote Forest - Setup AES encryption support

                    if ($EnableSelectiveAuthentication)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling selective authentication from $($RemoteForestObj.Name) to $($LocalForestObj.Name)."
                            Set-ADForestTrustSelectiveAuthentication -TrustingForest $LocalForestObj -TrustedForest $RemoveForestObj.Name -Enabled $true -Credential $RemoteForestCredential
                            Write-Verbose -Message "Successfully enabled selective authentication."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not establish selective authentication from $($RemoteForestObj.Name) to $($LocalForestObj.Name) : $($_.Exception.Message)."
                        }
                    }

                    if ($SidFilteringEnabled)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling SID filtering on local forest for an outbound trust."
						    Set-ADForestTrustSIDFiltering -TrustingForest $LocalForestObj -TrustedForest $RemoteForestObj.Name -SidFilteringEnabled $SidFilteringEnabled
                            Write-Verbose -Message "Successfully enabled SID filtering."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not enable SID filtering on the local forest: $($_.Exception.Message)."
                        }
                    }

                    if ($TrustingDomainSupportsKerberosAESEncryption)
                    {
                        try
                        {
                            Write-Verbose -Message "Enabling AES kerberos encryption in the local forest."
                            Set-ADForestTrustKerberosAESEncryption -TrustingForest $LocalForestObj.Name -TrustedForest $RemoteForestObj.Name
                            Write-Verbose -Message "Successfully enabled AES kerberos encryption."
                        }
                        catch [Exception]
                        {
                            Write-Warning -Message "Could not enable AES kerberos encryption in the local forest: $($_.Exception.Message)."
                        }
                    }
				}
            }
        }
	}

	End {		
	}
}

$script:UACValues = @(
			[PSCustomObject]@{Key="0x00000001";Value="ADS_UF_SCRIPT"},
			[PSCustomObject]@{Key="0x00000002";Value="ADS_UF_ACCOUNT_DISABLE"},
			[PSCustomObject]@{Key="0x00000008";Value="ADS_UF_HOMEDIR_REQUIRED"},
			[PSCustomObject]@{Key="0x00000010";Value="ADS_UF_LOCKOUT"}
			[PSCustomObject]@{Key="0x00000020";Value="ADS_UF_PASSWD_NOTREQD"},
			[PSCustomObject]@{Key="0x00000040";Value="ADS_UF_PASSWD_CANT_CHANGE"},
			[PSCustomObject]@{Key="0x00000080";Value="ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED"},
			[PSCustomObject]@{Key="0x00000100";Value="ADS_UF_TEMP_DUPLICATE_ACCOUNT"},
			[PSCustomObject]@{Key="0x00000200";Value="ADS_UF_NORMAL_ACCOUNT"},
			[PSCustomObject]@{Key="0x00000800";Value="ADS_UF_INTERDOMAIN_TRUST_ACCOUNT"},
			[PSCustomObject]@{Key="0x00001000";Value="ADS_UF_WORKSTATION_TRUST_ACCOUNT"},
			[PSCustomObject]@{Key="0x00002000";Value="ADS_UF_SERVER_TRUST_ACCOUNT"},
			[PSCustomObject]@{Key="0x00010000";Value="ADS_UF_DONT_EXPIRE_PASSWD"},
			[PSCustomObject]@{Key="0x00020000";Value="ADS_UF_MNS_LOGON_ACCOUNT"},
			[PSCustomObject]@{Key="0x00040000";Value="ADS_UF_SMARTCARD_REQUIRED"},
			[PSCustomObject]@{Key="0x00080000";Value="ADS_UF_TRUSTED_FOR_DELEGATION"},
			[PSCustomObject]@{Key="0x00100000";Value="ADS_UF_NOT_DELEGATED"},
			[PSCustomObject]@{Key="0x00200000";Value="ADS_UF_USE_DES_KEY_ONLY"},
			[PSCustomObject]@{Key="0x00400000";Value="ADS_UF_DONT_REQUIRE_PREAUTH"},
			[PSCustomObject]@{Key="0x00800000";Value="ADS_UF_PASSWORD_EXPIRED"},
			[PSCustomObject]@{Key="0x01000000";Value="ADS_UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION"},
			[PSCustomObject]@{Key="0x02000000";Value="ADS_UF_NO_AUTH_DATA_REQUIRED"},
			[PSCustomObject]@{Key="0x04000000";Value="ADS_UF_PARTIAL_SECRETS_ACCOUNT"}
		)

$script:TrustAttributes = @(
			[PSCustomObject]@{Key="0x00000001";Value="TRUST_ATTRIBUTE_NON_TRANSITIVE"},
			[PSCustomObject]@{Key="0x00000002";Value="TRUST_ATTRIBUTE_UPLEVEL_ONLY"},
			[PSCustomObject]@{Key="0x00000004";Value="TRUST_ATTRIBUTE_QUARANTINED_DOMAIN"},
			[PSCustomObject]@{Key="0x00000008";Value="TRUST_ATTRIBUTE_FOREST_TRANSITIVE"},
			[PSCustomObject]@{Key="0x00000010";Value="TRUST_ATTRIBUTE_CROSS_ORGANIZATION"}
			[PSCustomObject]@{Key="0x00000020";Value="TRUST_ATTRIBUTE_WITHIN_FOREST"},
			[PSCustomObject]@{Key="0x00000040";Value="TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL"},
			[PSCustomObject]@{Key="0x00000080";Value="TRUST_ATTRIBUTE_USES_RC4_ENCRYPTION"},
			[PSCustomObject]@{Key="0x00000200";Value="TRUST_ATTRIBUTE_CROSS_ORGANIZATION_NO_TGT_DELEGATION"},
			[PSCustomObject]@{Key="0x00000400";Value="TRUST_ATTRIBUTE_PIM_TRUST"}
		)

$script:AdSite = @"
using System;
using System.Runtime.InteropServices;

public static class NetApi32
{
	[DllImport("NetApi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern UInt32 DsGetSiteName([MarshalAs(UnmanagedType.LPWStr)]string ComputerName, out IntPtr SiteNameBuffer);

    [DllImport("NetApi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int NetApiBufferFree(IntPtr Buffer);

    private static void ThrowLastWin32Error()
    {
		Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
    }

    public static string DsGetSiteName()
    {
		return DsGetSiteName(String.Empty);

        // This only works for the local system
        // [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite();
    }

    public static string DsGetSiteName(string ComputerName)
    {
		IntPtr SiteNameBuffer = IntPtr.Zero;
        UInt32 HResult = DsGetSiteName(ComputerName, out SiteNameBuffer);
        string SiteName = Marshal.PtrToStringAuto(SiteNameBuffer);
        NetApiBufferFree(SiteNameBuffer);

        if (HResult != 0)
        {
			if (HResult == 0x00000005)
            {
				throw new Exception(String.Format("ERROR_ACCESS_DENIED : The function could not access the computer {0}.", ComputerName));
            }
            else if (HResult == 0x00000008)
            {
				throw new Exception("ERROR_NOT_ENOUGH_MEMORY : Not enough memory.");
            }
            else if (HResult == 0x0000077F)
            {
				throw new Exception("ERROR_NO_SITENAME : The computer is not assigned to a site.");
            }
            else if (HResult == 0x000006BA)
            {
				throw new Exception(String.Format("RPC_S_SERVER_UNAVAILABLE : ComputerName {0} not found.", ComputerName));
            }
            else
            {
				ThrowLastWin32Error();
            }
        }

        return SiteName;
    }
}
"@

$script:sceregvl = @"
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Security Configuration Template for Security Configuration Editor
;
; Template Name:        SCERegVl.INF
; Template Version:     05.00.DR.0000
;
; Revision History
; 0000  -       Original

[version]
signature="`$CHICAGO$"
DriverVer=06/21/2006,6.2.9200.16384

[Register Registry Values]
;
; Syntax: RegPath,RegType,DisplayName,DisplayType,Options
; where
;         RegPath:      Includes the registry keypath and value
;         RegType:      1 - REG_SZ, 2 - REG_EXPAND_SZ, 3 - REG_BINARY, 4 - REG_DWORD, 7 - REG_MULTI_SZ
;         Display Name: Is a localizable string defined in the [strings] section
;         Display type: 0 - boolean, 1 - Number, 2 - String, 3 - Choices, 4 - Multivalued, 5 - Bitmask
;         Options:      If Displaytype is 3 (Choices) or 5 (Bitmask), then specify the range of values and corresponding display strings
;                       in value|displaystring format separated by a comma.


MACHINE\System\CurrentControlSet\Control\Lsa\AuditBaseObjects,4,%AuditBaseObjects%,0
MACHINE\System\CurrentControlSet\Control\Lsa\CrashOnAuditFail,4,%CrashOnAuditFail%,0
MACHINE\System\CurrentControlSet\Control\Lsa\DisableDomainCreds,4,%DisableDomainCreds%,0
MACHINE\System\CurrentControlSet\Control\Lsa\EveryoneIncludesAnonymous,4,%EveryoneIncludesAnonymous%,0
MACHINE\System\CurrentControlSet\Control\Lsa\ForceGuest,4,%ForceGuest%,3,0|%Classic%,1|%GuestBased%
MACHINE\System\CurrentControlSet\Control\Lsa\FullPrivilegeAuditing,3,%FullPrivilegeAuditing%,0
MACHINE\System\CurrentControlSet\Control\Lsa\LimitBlankPasswordUse,4,%LimitBlankPasswordUse%,0
MACHINE\System\CurrentControlSet\Control\Lsa\LmCompatibilityLevel,4,%LmCompatibilityLevel%,3,0|%LMCLevel0%,1|%LMCLevel1%,2|%LMCLevel2%,3|%LMCLevel3%,4|%LMCLevel4%,5|%LMCLevel5%
MACHINE\System\CurrentControlSet\Control\Lsa\MSV1_0\NTLMMinClientSec,4,%NTLMMinClientSec%,5,524288|%NTLMv2Session%,536870912|%NTLM128%
MACHINE\System\CurrentControlSet\Control\Lsa\MSV1_0\NTLMMinServerSec,4,%NTLMMinServerSec%,5,524288|%NTLMv2Session%,536870912|%NTLM128%
MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash,4,%NoLMHash%,0
MACHINE\System\CurrentControlSet\Control\Lsa\RestrictAnonymous,4,%RestrictAnonymous%,0
MACHINE\System\CurrentControlSet\Control\Lsa\RestrictAnonymousSAM,4,%RestrictAnonymousSAM%,0
MACHINE\System\CurrentControlSet\Control\Lsa\SubmitControl,4,%SubmitControl%,0
MACHINE\System\CurrentControlSet\Control\Lsa\SCENoApplyLegacyAuditPolicy,4,%SCENoApplyLegacyAuditPolicy%,0

MACHINE\System\CurrentControlSet\Control\Print\Providers\LanMan Print Services\Servers\AddPrinterDrivers,4,%AddPrintDrivers%,0

MACHINE\System\CurrentControlSet\Control\SecurePipeServers\Winreg\AllowedPaths\Machine,7,%AllowedPaths%,4
MACHINE\System\CurrentControlSet\Control\SecurePipeServers\Winreg\AllowedExactPaths\Machine,7,%AllowedExactPaths%,4

MACHINE\System\CurrentControlSet\Control\Session Manager\Kernel\ObCaseInsensitive,4,%ObCaseInsensitive%,0
MACHINE\System\CurrentControlSet\Control\Session Manager\Memory Management\ClearPageFileAtShutdown,4,%ClearPageFileAtShutdown%,0
MACHINE\System\CurrentControlSet\Control\Session Manager\ProtectionMode,4,%ProtectionMode%,0
MACHINE\System\CurrentControlSet\Control\Session Manager\SubSystems\optional,7,%OptionalSubSystems%,4

MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\EnableSecuritySignature,4,%EnableSMBSignServer%,0
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\RequireSecuritySignature,4,%RequireSMBSignServer%,0
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\EnableForcedLogOff,4,%EnableForcedLogoff%,0
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\AutoDisconnect,4,%AutoDisconnect%,1,%Unit-Minutes%
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\RestrictNullSessAccess,4,%RestrictNullSessAccess%,0
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\NullSessionPipes,7,%NullPipes%,4
MACHINE\System\CurrentControlSet\Services\LanManServer\Parameters\NullSessionShares,7,%NullShares%,4

MACHINE\System\CurrentControlSet\Services\LanmanWorkstation\Parameters\EnableSecuritySignature,4,%EnableSMBSignRDR%,0
MACHINE\System\CurrentControlSet\Services\LanmanWorkstation\Parameters\RequireSecuritySignature,4,%RequireSMBSignRDR%,0
MACHINE\System\CurrentControlSet\Services\LanmanWorkstation\Parameters\EnablePlainTextPassword,4,%EnablePlainTextPassword%,0

MACHINE\System\CurrentControlSet\Services\LDAP\LDAPClientIntegrity,4,%LDAPClientIntegrity%,3,0|%LDAPClient0%,1|%LDAPClient1%,2|%LDAPClient2%

MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\DisablePasswordChange,4,%DisablePWChange%,0
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\MaximumPasswordAge,4,%MaximumPWAge%,1,%Unit-Days%
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\RefusePasswordChange,4,%RefusePWChange%,0
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\SignSecureChannel,4,%SignSecureChannel%,0
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\SealSecureChannel,4,%SealSecureChannel%,0
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\RequireSignOrSeal,4,%SignOrSeal%,0
MACHINE\System\CurrentControlSet\Services\Netlogon\Parameters\RequireStrongKey,4,%StrongKey%,0

MACHINE\System\CurrentControlSet\Services\NTDS\Parameters\LDAPServerIntegrity,4,%LDAPServerIntegrity%,3,1|%LDAPServer1%,2|%LDAPServer2%

MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableCAD,4,%DisableCAD%,0
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\DontDisplayLastUserName,4,%DontDisplayLastUserName%,0
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\DontDisplayLockedUserId,4,%DontDisplayLockedUserId%,3,1|%LockedUserID0%,2|%LockedUserID1%,3|%LockedUserID2%
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\LegalNoticeCaption,1,%LegalNoticeCaption%,2
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\LegalNoticeText,7,%LegalNoticeText%,4
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ScForceOption,4,%ScForceOption%,0
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ShutdownWithoutLogon,4,%ShutdownWithoutLogon%,0
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\UndockWithoutLogon,4,%UndockWithoutLogon%,0
MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\NoConnectedUser,4,%BlockConnectedUser%,3,0|%PolicyDisabled%,1|%BlockAdd%,3|%BlockLogin%

MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole\SecurityLevel,4,%RCAdmin%,0
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole\SetCommand,4,%RCSet%,0

MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\CachedLogonsCount,1,%CachedLogonsCount%,1,%Unit-Logons%
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\ForceUnlockLogon,4,%ForceUnlockLogon%,0
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\PasswordExpiryWarning,4,%PasswordExpiryWarning%,1,%Unit-Days%
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\ScRemoveOption,1,%ScRemove%,3,0|%ScRemove0%,1|%ScRemove1%,2|%ScRemove2%,3|%ScRemove3%

MACHINE\Software\Policies\Microsoft\Cryptography\ForceKeyProtection,4,%ForceHighProtection%,3,0|%CryptAllowNoUI%,1|%CryptAllowNoPass%,2|%CryptUsePass%
MACHINE\Software\Policies\Microsoft\Windows\Safer\CodeIdentifiers\AuthenticodeEnabled,4,%AuthenticodeEnabled%,0

MACHINE\Software\Policies\Microsoft\Windows NT\DCOM\MachineLaunchRestriction,1,%DCOMLaunchRestriction%,2
MACHINE\Software\Policies\Microsoft\Windows NT\DCOM\MachineAccessRestriction,1,%DCOMAccessRestriction%,2

; delete these values from the UI - Rdr in case NT4 w SCE
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\DisableCAD
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\DontDisplayLastUserName
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\LegalNoticeCaption
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\LegalNoticeText
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\ShutdownWithoutLogon
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\CmdConsSecurityLevel
MACHINE\System\CurrentControlSet\Control\Print\Providers\LanMan Print Services\AddPrintDrivers
MACHINE\System\CurrentControlSet\Services\MRxSMB\Parameters\EnableSecuritySignature
MACHINE\System\CurrentControlSet\Services\MRxSMB\Parameters\RequireSecuritySignature
MACHINE\System\CurrentControlSet\Services\MRxSMB\Parameters\EnablePlainTextPassword
MACHINE\System\CurrentControlSet\Services\Rdr\Parameters\EnableSecuritySignature
MACHINE\System\CurrentControlSet\Services\Rdr\Parameters\RequireSecuritySignature
MACHINE\System\CurrentControlSet\Services\Rdr\Parameters\EnablePlainTextPassword
MACHINE\Software\Microsoft\Windows\CurrentVersion\NetCache\EncryptEntireCache
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\EFS\AlgorithmID
MACHINE\Software\Microsoft\Non-Driver Signing\Policy
MACHINE\Software\Policies\Microsoft\Cryptography\ForceHighProtection


;========= Start of MSS Registry Values =========
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\AutoAdminLogon,1,%DisableAutoLogon%,0
MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl\AutoReboot,4,%AutoReboot%,0
MACHINE\System\CurrentControlSet\Services\LanmanServer\Parameters\AutoShareWks,4,%AdminShares%,0
MACHINE\System\CurrentControlSet\Services\LanmanServer\Parameters\AutoShareServer,4,%AdminSharesServer%,0
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\DisableIPSourceRouting,4,%DisableIPSourceRouting%,3,0|%DisableIPSourceRouting0%,1|%DisableIPSourceRouting1%,2|%DisableIPSourceRouting2%
MACHINE\SYSTEM\CurrentControlSet\Services\RasMan\Parameters\DisableSavePassword,4,%DisableSavePassword%,0
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\EnableDeadGWDetect,4,%EnableDeadGWDetect%,0
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\EnableICMPRedirect,4,%EnableICMPRedirect%,0
MACHINE\System\CurrentControlSet\Services\Lanmanserver\Parameters\Hidden,4,%HideFromBrowseList%,0
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\KeepAliveTime,4,%KeepAliveTime%,3,150000|%KeepAliveTime0%,300000|%KeepAliveTime1%,600000|%KeepAliveTime2%,1200000|%KeepAliveTime3%,2400000|%KeepAliveTime4%,3600000|%KeepAliveTime5%,7200000|%KeepAliveTime6%
MACHINE\System\CurrentControlSet\Services\IPSEC\NoDefaultExempt,4,%NoDefaultExempt%,3,0|%NoDefaultExempt0%,1|%NoDefaultExempt1%,2|%NoDefaultExempt2%,3|%NoDefaultExempt3% 
MACHINE\System\CurrentControlSet\Services\Netbt\Parameters\NoNameReleaseOnDemand,4,%NoNameReleaseOnDemand%,0
MACHINE\System\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation,4,%NtfsDisable8dot3NameCreation%,3,0|%NtfsDisable8dot3NameCreation0%,1|%NtfsDisable8dot3NameCreation1%,2|%NtfsDisable8dot3NameCreation2%,3|%NtfsDisable8dot3NameCreation3%
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\PerformRouterDiscovery,4,%PerformRouterDiscovery%,0
MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SafeDllSearchMode,4,%SafeDllSearchMode%,0
MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\ScreenSaverGracePeriod,1,%ScreenSaverGracePeriod%,1
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\SynAttackProtect,4,%SynAttackProtect%,3,0|%SynAttackProtect0%,1|%SynAttackProtect1%
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\TcpMaxConnectResponseRetransmissions,4,%TcpMaxConnectResponseRetransmissions%,3,0|%TcpMaxConnectResponseRetransmissions0%,1|%TcpMaxConnectResponseRetransmissions1%,2|%TcpMaxConnectResponseRetransmissions2%,3|%TcpMaxConnectResponseRetransmissions3%
MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\TcpMaxDataRetransmissions,4,%TcpMaxDataRetransmissions%,1
MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Security\WarningLevel,4,%WarningLevel%,3,50|%WarningLevel0%,60|%WarningLevel1%,70|%WarningLevel2%,80|%WarningLevel3%,90|%WarningLevel4%
MACHINE\System\CurrentControlSet\Services\Tcpip6\Parameters\DisableIPSourceRouting,4,%DisableIPSourceRoutingIPv6%,3,0|%DisableIPSourceRouting0%,1|%DisableIPSourceRouting1%,2|%DisableIPSourceRouting2% 
MACHINE\System\CurrentControlSet\Services\Tcpip6\Parameters\TcpMaxDataRetransmissions ,4,%TcpMaxDataRetransmissionsIPv6%,1
;========= End of MSS Registry Values =========


[Strings]
;========= Start of MSS Strings Values =========
DisableAutoLogon = "MSS: (AutoAdminLogon) Enable Automatic Logon (not recommended)" 
AutoReboot = "MSS: (AutoReboot) Allow Windows to automatically restart after a system crash (recommended except for highly secure environments)"
AdminShares = "MSS: (AutoShareWks) Enable Administrative Shares (recommended except for highly secure environments)" 
AdminSharesServer = "MSS: (AutoShareServer) Enable Administrative Shares (recommended except for highly secure environments)" 
DisableIPSourceRouting = "MSS: (DisableIPSourceRouting) IP source routing protection level (protects against packet spoofing)"
DisableIPSourceRoutingIPv6 = "MSS: (DisableIPSourceRouting IPv6) IP source routing protection level (protects against packet spoofing)"
DisableIPSourceRouting0 = "No additional protection, source routed packets are allowed"
DisableIPSourceRouting1 = "Medium, source routed packets ignored when IP forwarding is enabled"
DisableIPSourceRouting2 = "Highest protection, source routing is completely disabled"
DisableSavePassword = "MSS: (DisableSavePassword) Prevent the dial-up passsword from being saved (recommended)"
EnableDeadGWDetect = "MSS: (EnableDeadGWDetect) Allow automatic detection of dead network gateways (could lead to DoS)"
EnableICMPRedirect = "MSS: (EnableICMPRedirect) Allow ICMP redirects to override OSPF generated routes"
HideFromBrowseList = "MSS: (Hidden) Hide Computer From the Browse List (not recommended except for highly secure environments)"
KeepAliveTime = "MSS: (KeepAliveTime) How often keep-alive packets are sent in milliseconds"
KeepAliveTime0 ="150000 or 2.5 minutes"
KeepAliveTime1 ="300000 or 5 minutes (recommended)" 
KeepAliveTime2 ="600000 or 10 minutes"
KeepAliveTime3 ="1200000 or 20 minutes"
KeepAliveTime4 ="2400000 or 40 minutes"
KeepAliveTime5 ="3600000 or 1 hour"
KeepAliveTime6 ="7200000 or 2 hours (default value)"
NoDefaultExempt = "MSS: (NoDefaultExempt) Configure IPSec exemptions for various types of network traffic." 
NoDefaultExempt0 = "Allow all exemptions (least secure)."
NoDefaultExempt1 = "Multicast, broadcast, & ISAKMP exempt (best for Windows XP)."
NoDefaultExempt2 = "RSVP, Kerberos, and ISAKMP are exempt."
NoDefaultExempt3 = "Only ISAKMP is exempt (recommended for Windows Server 2003)." 
NoNameReleaseOnDemand = "MSS: (NoNameReleaseOnDemand) Allow the computer to ignore NetBIOS name release requests except from WINS servers"
NtfsDisable8dot3NameCreation = "MSS: (NtfsDisable8dot3NameCreation) Enable the computer to stop generating 8.3 style filenames"
NtfsDisable8dot3NameCreation0 = "Enable 8Dot3 Creation on all Volumes"
NtfsDisable8dot3NameCreation1 = "Disable 8Dot3 Creation on all Volumes"
NtfsDisable8dot3NameCreation2 = "Set 8dot3 name creation per volume using FSUTIL (Windows 7 or later)
NtfsDisable8dot3NameCreation3 = "Disable 8Dot3 name creation on all volumes except system volume (Windows 7 or later)"
PerformRouterDiscovery = "MSS: (PerformRouterDiscovery) Allow IRDP to detect and configure Default Gateway addresses (could lead to DoS)"
SafeDllSearchMode = "MSS: (SafeDllSearchMode) Enable Safe DLL search mode (recommended)"
ScreenSaverGracePeriod = "MSS: (ScreenSaverGracePeriod) The time in seconds before the screen saver grace period expires (0 recommended)"
SynAttackProtect = "MSS: (SynAttackProtect) Syn attack protection level (protects against DoS)"
SynAttackProtect0 = "No additional protection, use default settings"
SynAttackProtect1 = "Connections time out sooner if a SYN attack is detected"
TcpMaxConnectResponseRetransmissions = "MSS: (TcpMaxConnectResponseRetransmissions) SYN-ACK retransmissions when a connection request is not acknowledged"
TcpMaxConnectResponseRetransmissions0 = "No retransmission, half-open connections dropped after 3 seconds"
TcpMaxConnectResponseRetransmissions1 = "3 seconds, half-open connections dropped after 9 seconds"
TcpMaxConnectResponseRetransmissions2 = "3 & 6 seconds, half-open connections dropped after 21 seconds"
TcpMaxConnectResponseRetransmissions3 = "3, 6, & 9 seconds, half-open connections dropped after 45 seconds"
TcpMaxDataRetransmissions = "MSS: (TcpMaxDataRetransmissions) How many times unacknowledged data is retransmitted (3 recommended, 5 is default)"
TcpMaxDataRetransmissionsIPv6 = "MSS: (TcpMaxDataRetransmissions IPv6) How many times unacknowledged data is retransmitted (3 recommended, 5 is default)"
WarningLevel = "MSS: (WarningLevel) Percentage threshold for the security event log at which the system will generate a warning"
WarningLevel0 = "50%"
WarningLevel1 = "60%"
WarningLevel2 = "70%"
WarningLevel3 = "80%"
WarningLevel4 = "90%"
;========= End of MSS Strings Values =========

;================================ Accounts ============================================================================
;Specified in UI code - Accounts: Administrator account status
;Specified in UI code - Accounts: Guest account status
;Specified in UI code - Accounts: Rename administrator account
;Specified in UI code - Accounts: Rename guest account
LimitBlankPasswordUse = "@wsecedit.dll,-59001"
BlockConnectedUser = "@wsecedit.dll,-59150"
PolicyDisabled = "@wsecedit.dll,-59151"
BlockAdd = "@wsecedit.dll,-59152"
BlockLogin = "@wsecedit.dll,-59153"

;================================ Audit ===============================================================================

AuditBaseObjects="@wsecedit.dll,-59002"
FullPrivilegeAuditing="@wsecedit.dll,-59003"
CrashOnAuditFail="@wsecedit.dll,-59004"
SCENoApplyLegacyAuditPolicy="@wsecedit.dll,-59104"

;================================ Devices =============================================================================
AddPrintDrivers="@wsecedit.dll,-59005"
UndockWithoutLogon="@wsecedit.dll,-59010"

;================================ Domain controller ====================================================================
SubmitControl="@wsecedit.dll,-59011"
RefusePWChange="@wsecedit.dll,-59012"
LDAPServerIntegrity = "@wsecedit.dll,-59013"
LDAPServer1 = "@wsecedit.dll,-59014"
LDAPServer2 = "@wsecedit.dll,-59015"

;================================ Domain member ========================================================================
DisablePWChange="@wsecedit.dll,-59016"
MaximumPWAge="@wsecedit.dll,-59017"
SignOrSeal="@wsecedit.dll,-59018"
SealSecureChannel="@wsecedit.dll,-59019"
SignSecureChannel="@wsecedit.dll,-59020"
StrongKey="@wsecedit.dll,-59021"

;================================ Interactive logon ====================================================================
DisableCAD = "@wsecedit.dll,-59022"
DontDisplayLastUserName = "@wsecedit.dll,-59023"
DontDisplayLockedUserId = "@wsecedit.dll,-59024"
LockedUserId0 = "@wsecedit.dll,-59025"
LockedUserId1 = "@wsecedit.dll,-59026"
LockedUserId2 = "@wsecedit.dll,-59027"
LegalNoticeText = "@wsecedit.dll,-59028"
LegalNoticeCaption = "@wsecedit.dll,-59029"
CachedLogonsCount = "@wsecedit.dll,-59030"
PasswordExpiryWarning = "@wsecedit.dll,-59031"
ForceUnlockLogon = "@wsecedit.dll,-59032"
ScForceOption = "@wsecedit.dll,-59033"
ScRemove = "@wsecedit.dll,-59034"
ScRemove0 = "@wsecedit.dll,-59035"
ScRemove1 = "@wsecedit.dll,-59036"
ScRemove2 = "@wsecedit.dll,-59037"
ScRemove3 = "@wsecedit.dll,-59038"

;================================ Microsoft network client =============================================================
RequireSMBSignRdr="@wsecedit.dll,-59039"
EnableSMBSignRdr="@wsecedit.dll,-59040"
EnablePlainTextPassword="@wsecedit.dll,-59041"

;================================ Microsoft network server =============================================================
AutoDisconnect="@wsecedit.dll,-59042"
RequireSMBSignServer="@wsecedit.dll,-59043"
EnableSMBSignServer="@wsecedit.dll,-59044"
EnableForcedLogoff="@wsecedit.dll,-59045"

;================================ Network access =======================================================================
;Specified in UI code - Network access: Allow anonymous SID/Name translation
DisableDomainCreds = "@wsecedit.dll,-59046"
RestrictAnonymousSAM = "@wsecedit.dll,-59047"
RestrictAnonymous = "@wsecedit.dll,-59048"
EveryoneIncludesAnonymous = "@wsecedit.dll,-59049"
RestrictNullSessAccess = "@wsecedit.dll,-59050"
NullPipes = "@wsecedit.dll,-59051"
NullShares = "@wsecedit.dll,-59052"
AllowedPaths = "@wsecedit.dll,-59053"
AllowedExactPaths = "@wsecedit.dll,-59054"
ForceGuest = "@wsecedit.dll,-59055"
Classic = "@wsecedit.dll,-59056"
GuestBased = "@wsecedit.dll,-59057"

;================================ Network security =====================================================================
;Specified in UI code - Network security: Enforce logon hour restrictions
NoLMHash = "@wsecedit.dll,-59058"
LmCompatibilityLevel = "@wsecedit.dll,-59059"
LMCLevel0 = "@wsecedit.dll,-59060"
LMCLevel1 = "@wsecedit.dll,-59061"
LMCLevel2 = "@wsecedit.dll,-59062"
LMCLevel3 = "@wsecedit.dll,-59063"
LMCLevel4 = "@wsecedit.dll,-59064"
LMCLevel5 = "@wsecedit.dll,-59065"
NTLMMinClientSec = "@wsecedit.dll,-59066"
NTLMMinServerSec = "@wsecedit.dll,-59067"
NTLMv2Session = "@wsecedit.dll,-59070"
NTLM128 = "@wsecedit.dll,-59071"
LDAPClientIntegrity = "@wsecedit.dll,-59072"
LDAPClient0 = "@wsecedit.dll,-59073"
LDAPClient1 = "@wsecedit.dll,-59074"
LDAPClient2 = "@wsecedit.dll,-59075"

;================================ Recovery console ====================================================================
RCAdmin="@wsecedit.dll,-59076"
RCSet="@wsecedit.dll,-59077"

;================================ Shutdown ============================================================================
ShutdownWithoutLogon="@wsecedit.dll,-59078"
ClearPageFileAtShutdown="@wsecedit.dll,-59079"

ProtectionMode = "@wsecedit.dll,-59080"
ObCaseInsensitive = "@wsecedit.dll,-59084"

;================================ System cryptography =================================================================
FIPS="@wsecedit.dll,-59085"

ForceHighProtection="@wsecedit.dll,-59086"

CryptAllowNoUI="@wsecedit.dll,-59087"
CryptAllowNoPass="@wsecedit.dll,-59088"
CryptUsePass="@wsecedit.dll,-59089"


;================================ System Settings =====================================================================
AuthenticodeEnabled = "@wsecedit.dll,-59090"
OptionalSubSystems = "@wsecedit.dll,-59091"


Unit-Logons="@wsecedit.dll,-59092"
Unit-Days="@wsecedit.dll,-59093"
Unit-Minutes="@wsecedit.dll,-59094"
Unit-Seconds="@wsecedit.dll,-59095"

;================================ DCOM Machine Restrictions ===========================================================
DCOMLaunchRestriction="@wsecedit.dll,-59096"
DCOMAccessRestriction="@wsecedit.dll,-59097"

"@